CCS PCH C Compiler, Version 5.073, 37395               12-Set-17 12:01

               Filename:   C:\Users\victor.andrade\Desktop\Nova pasta\FW Sistema Prioridade V0.8\rr2_USB_Monitor.lst

               ROM used:   12288 bytes (9%)
                           Largest free fragment is 65528
               RAM used:   271 (7%) at main() level
                           303 (8%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   2644
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   015C
00068:  BTFSS  FA3.5
0006A:  GOTO   0074
0006E:  BTFSC  FA4.5
00070:  GOTO   00E4
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... /* 
.................... +++++++++++++++++ Programa Sistema de Prioridade  ++++++++++++++++++++++++++++ 
....................  
.................... //////// Program memory: 65532x16  Data RAM: 4096  Stack: 31 
.................... //////// I/O: 70   Analog Pins: 16 
.................... //////// C Scratch area: 00   ID Location: 0000 
.................... //////// Fuses: HS,H4_SW,EC_IO,E4_SW_IO,DEBUG,NODEBUG,XINST,NOXINST,STVREN 
.................... //////// Fuses: NOSTVREN,WDT,NOWDT,PROTECT,NOPROTECT,WDT1,WDT2,WDT4,WDT8 
.................... //////// Fuses: WDT16,WDT32,WDT64,WDT128,WDT256,WDT512,WDT1024,WDT2048 
.................... //////// Fuses: WDT4096,WDT8192,WDT16384,WDT32768,FCMEN,NOFCMEN,IESO,NOIESO 
.................... //////// Fuses: CCP2C1,CCP2E7,PRIMARY,INTRC,ECCPE,ECCPH,ETHLED,NOETHLED,WAIT 
.................... //////// Fuses: NOWAIT,BW16,BW8,MCU,EMCU12,EMCU16,EMCU20,EASHFT,NOEASHFT 
.................... ////////  
.................... // Watch Dog Timer Functions: SETUP_WDT() or SETUP_COUNTERS() (see above) 
.................... //                            RESTART_WDT() 
.................... SETUP_WDT(WDT_ON) 
.................... RESTART_WDT() 
.................... //#define WDT_ON        0x100 
.................... //#define WDT_OFF       0 
....................  
.................... */ 
....................  
.................... #include <18F97J60.h> 
.................... //////////// Standard Header file for the PIC18F97J60 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F97J60 
*
0029C:  DATA 4D,6F
0029E:  DATA 64,6F
002A0:  DATA 20,4C
002A2:  DATA 69,6E
002A4:  DATA 68,61
002A6:  DATA 20,64
002A8:  DATA 65,20
002AA:  DATA 43,6F
002AC:  DATA 6D,61
002AE:  DATA 6E,64
002B0:  DATA 6F,73
002B2:  DATA 20,41
002B4:  DATA 63,74
002B6:  DATA 69,76
002B8:  DATA 61,64
002BA:  DATA 6F,0A
002BC:  DATA 0D,00
002BE:  DATA 4D,6F
002C0:  DATA 64,6F
002C2:  DATA 20,4C
002C4:  DATA 69,6E
002C6:  DATA 68,61
002C8:  DATA 20,64
002CA:  DATA 65,20
002CC:  DATA 43,6F
002CE:  DATA 6D,61
002D0:  DATA 6E,64
002D2:  DATA 6F,73
002D4:  DATA 20,44
002D6:  DATA 65,73
002D8:  DATA 61,63
002DA:  DATA 74,69
002DC:  DATA 76,61
002DE:  DATA 64,6F
002E0:  DATA 0A,0D
002E2:  DATA 00,00
002E4:  DATA 54,65
002E6:  DATA 6D,70
002E8:  DATA 6F,20
002EA:  DATA 56,65
002EC:  DATA 72,64
002EE:  DATA 65,20
002F0:  DATA 6D,ED
002F2:  DATA 6E,69
002F4:  DATA 6D,6F
002F6:  DATA 20,47
002F8:  DATA 31,5B
002FA:  DATA 73,65
002FC:  DATA 67,5D
002FE:  DATA 3D,25
00300:  DATA 75,0A
00302:  DATA 0D,00
00304:  DATA 54,65
00306:  DATA 6D,70
00308:  DATA 6F,20
0030A:  DATA 56,65
0030C:  DATA 72,64
0030E:  DATA 65,20
00310:  DATA 6D,E1
00312:  DATA 78,69
00314:  DATA 6D,6F
00316:  DATA 20,47
00318:  DATA 31,5B
0031A:  DATA 73,65
0031C:  DATA 67,5D
0031E:  DATA 3D,25
00320:  DATA 75,0A
00322:  DATA 0D,00
00324:  DATA 54,65
00326:  DATA 6D,70
00328:  DATA 6F,20
0032A:  DATA 49,6E
0032C:  DATA 63,72
0032E:  DATA 65,6D
00330:  DATA 65,6E
00332:  DATA 74,6F
00334:  DATA 20,47
00336:  DATA 31,5B
00338:  DATA 73,65
0033A:  DATA 67,5D
0033C:  DATA 3D,25
0033E:  DATA 75,0A
00340:  DATA 0D,00
00342:  DATA 54,65
00344:  DATA 6D,70
00346:  DATA 6F,20
00348:  DATA 56,65
0034A:  DATA 72,64
0034C:  DATA 65,20
0034E:  DATA 6D,ED
00350:  DATA 6E,69
00352:  DATA 6D,6F
00354:  DATA 20,47
00356:  DATA 32,5B
00358:  DATA 73,65
0035A:  DATA 67,5D
0035C:  DATA 3D,25
0035E:  DATA 75,0A
00360:  DATA 0D,00
00362:  DATA 54,65
00364:  DATA 6D,70
00366:  DATA 6F,20
00368:  DATA 56,65
0036A:  DATA 72,64
0036C:  DATA 65,20
0036E:  DATA 6D,E1
00370:  DATA 78,69
00372:  DATA 6D,6F
00374:  DATA 20,47
00376:  DATA 32,20
00378:  DATA 5B,73
0037A:  DATA 65,67
0037C:  DATA 5D,3D
0037E:  DATA 25,75
00380:  DATA 0A,0D
00382:  DATA 00,00
00384:  DATA 54,65
00386:  DATA 6D,70
00388:  DATA 6F,20
0038A:  DATA 49,6E
0038C:  DATA 63,72
0038E:  DATA 65,6D
00390:  DATA 65,6E
00392:  DATA 74,6F
00394:  DATA 20,47
00396:  DATA 32,20
00398:  DATA 5B,73
0039A:  DATA 65,67
0039C:  DATA 5D,3D
0039E:  DATA 25,75
003A0:  DATA 0A,0D
003A2:  DATA 00,00
003A4:  DATA 54,65
003A6:  DATA 6D,70
003A8:  DATA 6F,20
003AA:  DATA 56,65
003AC:  DATA 72,64
003AE:  DATA 65,20
003B0:  DATA 6D,ED
003B2:  DATA 6E,69
003B4:  DATA 6D,6F
003B6:  DATA 20,47
003B8:  DATA 33,20
003BA:  DATA 5B,73
003BC:  DATA 65,67
003BE:  DATA 5D,3D
003C0:  DATA 25,75
003C2:  DATA 0A,0D
003C4:  DATA 00,00
003C6:  DATA 54,65
003C8:  DATA 6D,70
003CA:  DATA 6F,20
003CC:  DATA 56,65
003CE:  DATA 72,64
003D0:  DATA 65,20
003D2:  DATA 6D,E1
003D4:  DATA 78,69
003D6:  DATA 6D,6F
003D8:  DATA 20,47
003DA:  DATA 33,20
003DC:  DATA 5B,73
003DE:  DATA 65,67
003E0:  DATA 5D,3D
003E2:  DATA 25,75
003E4:  DATA 0A,0D
003E6:  DATA 00,00
003E8:  DATA 54,65
003EA:  DATA 6D,70
003EC:  DATA 6F,20
003EE:  DATA 49,6E
003F0:  DATA 63,72
003F2:  DATA 65,6D
003F4:  DATA 65,6E
003F6:  DATA 74,6F
003F8:  DATA 20,47
003FA:  DATA 33,20
003FC:  DATA 5B,73
003FE:  DATA 65,67
00400:  DATA 5D,3D
00402:  DATA 25,75
00404:  DATA 0A,0D
00406:  DATA 00,00
00408:  DATA 54,65
0040A:  DATA 6D,70
0040C:  DATA 6F,20
0040E:  DATA 50,65
00410:  DATA 72,63
00412:  DATA 75,72
00414:  DATA 73,6F
00416:  DATA 20,47
00418:  DATA 31,20
0041A:  DATA 2D,3E
0041C:  DATA 20,47
0041E:  DATA 32,20
00420:  DATA 5B,73
00422:  DATA 65,67
00424:  DATA 5D,3D
00426:  DATA 25,75
00428:  DATA 0A,0D
0042A:  DATA 00,00
0042C:  DATA 54,65
0042E:  DATA 6D,70
00430:  DATA 6F,20
00432:  DATA 50,65
00434:  DATA 72,63
00436:  DATA 75,72
00438:  DATA 73,6F
0043A:  DATA 20,47
0043C:  DATA 32,20
0043E:  DATA 2D,3E
00440:  DATA 20,47
00442:  DATA 31,20
00444:  DATA 5B,73
00446:  DATA 65,67
00448:  DATA 5D,3D
0044A:  DATA 25,75
0044C:  DATA 0A,0D
0044E:  DATA 00,00
00450:  DATA 54,65
00452:  DATA 6D,70
00454:  DATA 6F,20
00456:  DATA 50,65
00458:  DATA 72,63
0045A:  DATA 75,72
0045C:  DATA 73,6F
0045E:  DATA 20,47
00460:  DATA 31,20
00462:  DATA 2D,3E
00464:  DATA 20,47
00466:  DATA 33,20
00468:  DATA 5B,73
0046A:  DATA 65,67
0046C:  DATA 5D,3D
0046E:  DATA 25,75
00470:  DATA 0A,0D
00472:  DATA 00,00
00474:  DATA 54,65
00476:  DATA 6D,70
00478:  DATA 6F,20
0047A:  DATA 50,65
0047C:  DATA 72,63
0047E:  DATA 75,72
00480:  DATA 73,6F
00482:  DATA 20,47
00484:  DATA 33,20
00486:  DATA 2D,3E
00488:  DATA 20,47
0048A:  DATA 31,20
0048C:  DATA 5B,73
0048E:  DATA 65,67
00490:  DATA 5D,3D
00492:  DATA 25,75
00494:  DATA 0A,0D
00496:  DATA 00,00
00498:  DATA 54,65
0049A:  DATA 6D,70
0049C:  DATA 6F,20
0049E:  DATA 50,65
004A0:  DATA 72,63
004A2:  DATA 75,72
004A4:  DATA 73,6F
004A6:  DATA 20,47
004A8:  DATA 32,20
004AA:  DATA 2D,3E
004AC:  DATA 20,47
004AE:  DATA 33,20
004B0:  DATA 5B,73
004B2:  DATA 65,67
004B4:  DATA 5D,3D
004B6:  DATA 25,75
004B8:  DATA 0A,0D
004BA:  DATA 00,00
004BC:  DATA 54,65
004BE:  DATA 6D,70
004C0:  DATA 6F,20
004C2:  DATA 50,65
004C4:  DATA 72,63
004C6:  DATA 75,72
004C8:  DATA 73,6F
004CA:  DATA 20,47
004CC:  DATA 33,20
004CE:  DATA 2D,3E
004D0:  DATA 20,47
004D2:  DATA 32,20
004D4:  DATA 5B,73
004D6:  DATA 65,67
004D8:  DATA 5D,3D
004DA:  DATA 25,75
004DC:  DATA 0A,0D
004DE:  DATA 00,00
004E0:  DATA 54,69
004E2:  DATA 6D,65
004E4:  DATA 6F,75
004E6:  DATA 74,20
004E8:  DATA 44,65
004EA:  DATA 73,62
004EC:  DATA 6C,6F
004EE:  DATA 71,75
004F0:  DATA 65,69
004F2:  DATA 6F,3D
004F4:  DATA 25,75
004F6:  DATA 0A,0D
004F8:  DATA 00,00
004FA:  DATA 44,65
004FC:  DATA 62,75
004FE:  DATA 67,3D
00500:  DATA 44,65
00502:  DATA 73,61
00504:  DATA 62,69
00506:  DATA 6C,69
00508:  DATA 74,61
0050A:  DATA 64,6F
0050C:  DATA 0A,0D
0050E:  DATA 00,00
00510:  DATA 44,65
00512:  DATA 62,75
00514:  DATA 67,3D
00516:  DATA 48,61
00518:  DATA 62,69
0051A:  DATA 6C,69
0051C:  DATA 74,61
0051E:  DATA 64,6F
00520:  DATA 0A,0D
00522:  DATA 00,00
00524:  DATA 44,65
00526:  DATA 62,75
00528:  DATA 67,20
0052A:  DATA 49,6E
0052C:  DATA 70,75
0052E:  DATA 74,73
00530:  DATA 3D,44
00532:  DATA 65,73
00534:  DATA 61,62
00536:  DATA 69,6C
00538:  DATA 69,74
0053A:  DATA 61,64
0053C:  DATA 6F,0A
0053E:  DATA 0D,00
00540:  DATA 44,65
00542:  DATA 62,75
00544:  DATA 67,20
00546:  DATA 49,6E
00548:  DATA 70,75
0054A:  DATA 74,73
0054C:  DATA 3D,48
0054E:  DATA 61,62
00550:  DATA 69,6C
00552:  DATA 69,74
00554:  DATA 61,64
00556:  DATA 6F,0A
00558:  DATA 0D,00
0055A:  DATA 59,45
0055C:  DATA 41,52
0055E:  DATA 3D,25
00560:  DATA 75,0A
00562:  DATA 0D,00
00564:  DATA 4D,4F
00566:  DATA 4E,54
00568:  DATA 48,3D
0056A:  DATA 25,75
0056C:  DATA 0A,0D
0056E:  DATA 00,00
00570:  DATA 44,61
00572:  DATA 74,65
00574:  DATA 3D,25
00576:  DATA 75,0A
00578:  DATA 0D,00
0057A:  DATA 44,61
0057C:  DATA 79,4F
0057E:  DATA 66,57
00580:  DATA 65,65
00582:  DATA 6B,3D
00584:  DATA 25,75
00586:  DATA 0A,0D
00588:  DATA 00,00
0058A:  DATA 48,4F
0058C:  DATA 55,52
0058E:  DATA 3D,25
00590:  DATA 75,0A
00592:  DATA 0D,00
00594:  DATA 4D,49
00596:  DATA 4E,55
00598:  DATA 54,45
0059A:  DATA 3D,25
0059C:  DATA 75,0A
0059E:  DATA 0D,00
005A0:  DATA 53,45
005A2:  DATA 43,4F
005A4:  DATA 4E,44
005A6:  DATA 3D,25
005A8:  DATA 75,0A
005AA:  DATA 0D,00
005AC:  DATA 49,6E
005AE:  DATA 70,75
005B0:  DATA 74,20
005B2:  DATA 31,20
005B4:  DATA 2D,3E
005B6:  DATA 20,4F
005B8:  DATA 4E,0A
005BA:  DATA 0D,00
005BC:  DATA 49,6E
005BE:  DATA 70,75
005C0:  DATA 74,20
005C2:  DATA 31,20
005C4:  DATA 2D,3E
005C6:  DATA 20,4F
005C8:  DATA 46,46
005CA:  DATA 0A,0D
005CC:  DATA 00,00
005CE:  DATA 49,6E
005D0:  DATA 70,75
005D2:  DATA 74,20
005D4:  DATA 32,2D
005D6:  DATA 3E,20
005D8:  DATA 4F,4E
005DA:  DATA 0A,0D
005DC:  DATA 00,00
005DE:  DATA 49,6E
005E0:  DATA 70,75
005E2:  DATA 74,20
005E4:  DATA 32,2D
005E6:  DATA 3E,20
005E8:  DATA 4F,46
005EA:  DATA 46,0A
005EC:  DATA 0D,00
005EE:  DATA 49,6E
005F0:  DATA 70,75
005F2:  DATA 74,20
005F4:  DATA 33,2D
005F6:  DATA 3E,20
005F8:  DATA 4F,4E
005FA:  DATA 0A,0D
005FC:  DATA 00,00
005FE:  DATA 49,6E
00600:  DATA 70,75
00602:  DATA 74,20
00604:  DATA 33,2D
00606:  DATA 3E,20
00608:  DATA 4F,46
0060A:  DATA 46,0A
0060C:  DATA 0D,00
0060E:  DATA 49,6E
00610:  DATA 70,75
00612:  DATA 74,20
00614:  DATA 34,2D
00616:  DATA 3E,20
00618:  DATA 4F,4E
0061A:  DATA 0A,0D
0061C:  DATA 00,00
0061E:  DATA 49,6E
00620:  DATA 70,75
00622:  DATA 74,20
00624:  DATA 34,2D
00626:  DATA 3E,20
00628:  DATA 4F,46
0062A:  DATA 46,0A
0062C:  DATA 0D,00
0062E:  DATA 49,6E
00630:  DATA 70,75
00632:  DATA 74,20
00634:  DATA 35,2D
00636:  DATA 3E,20
00638:  DATA 4F,4E
0063A:  DATA 0A,0D
0063C:  DATA 00,00
0063E:  DATA 49,6E
00640:  DATA 70,75
00642:  DATA 74,20
00644:  DATA 35,2D
00646:  DATA 3E,20
00648:  DATA 4F,46
0064A:  DATA 46,0A
0064C:  DATA 0D,00
0064E:  DATA 49,6E
00650:  DATA 70,75
00652:  DATA 74,20
00654:  DATA 36,2D
00656:  DATA 3E,20
00658:  DATA 4F,4E
0065A:  DATA 0A,0D
0065C:  DATA 00,00
0065E:  DATA 49,6E
00660:  DATA 70,75
00662:  DATA 74,20
00664:  DATA 36,2D
00666:  DATA 3E,20
00668:  DATA 4F,46
0066A:  DATA 46,0A
0066C:  DATA 0D,00
0066E:  DATA 49,6E
00670:  DATA 70,75
00672:  DATA 74,20
00674:  DATA 37,2D
00676:  DATA 3E,20
00678:  DATA 4F,4E
0067A:  DATA 0A,0D
0067C:  DATA 00,00
0067E:  DATA 49,6E
00680:  DATA 70,75
00682:  DATA 74,20
00684:  DATA 37,2D
00686:  DATA 3E,20
00688:  DATA 4F,46
0068A:  DATA 46,0A
0068C:  DATA 0D,00
0068E:  DATA 49,6E
00690:  DATA 70,75
00692:  DATA 74,20
00694:  DATA 38,2D
00696:  DATA 3E,20
00698:  DATA 4F,4E
0069A:  DATA 0A,0D
0069C:  DATA 00,00
0069E:  DATA 49,6E
006A0:  DATA 70,75
006A2:  DATA 74,20
006A4:  DATA 38,2D
006A6:  DATA 3E,20
006A8:  DATA 4F,46
006AA:  DATA 46,0A
006AC:  DATA 0D,00
006AE:  DATA 49,6E
006B0:  DATA 70,75
006B2:  DATA 74,20
006B4:  DATA 39,2D
006B6:  DATA 3E,20
006B8:  DATA 4F,4E
006BA:  DATA 0A,0D
006BC:  DATA 00,00
006BE:  DATA 49,6E
006C0:  DATA 70,75
006C2:  DATA 74,20
006C4:  DATA 39,2D
006C6:  DATA 3E,20
006C8:  DATA 4F,46
006CA:  DATA 46,0A
006CC:  DATA 0D,00
006CE:  DATA 49,6E
006D0:  DATA 70,75
006D2:  DATA 74,20
006D4:  DATA 31,30
006D6:  DATA 2D,3E
006D8:  DATA 20,4F
006DA:  DATA 4E,0A
006DC:  DATA 0D,00
006DE:  DATA 49,6E
006E0:  DATA 70,75
006E2:  DATA 74,20
006E4:  DATA 31,30
006E6:  DATA 2D,3E
006E8:  DATA 20,4F
006EA:  DATA 46,46
006EC:  DATA 0A,0D
006EE:  DATA 00,00
006F0:  DATA 49,6E
006F2:  DATA 70,75
006F4:  DATA 74,20
006F6:  DATA 31,31
006F8:  DATA 2D,3E
006FA:  DATA 20,4F
006FC:  DATA 4E,0A
006FE:  DATA 0D,00
00700:  DATA 49,6E
00702:  DATA 70,75
00704:  DATA 74,20
00706:  DATA 31,31
00708:  DATA 2D,3E
0070A:  DATA 20,4F
0070C:  DATA 46,46
0070E:  DATA 0A,0D
00710:  DATA 00,00
00712:  DATA 49,6E
00714:  DATA 70,75
00716:  DATA 74,20
00718:  DATA 31,32
0071A:  DATA 2D,3E
0071C:  DATA 20,4F
0071E:  DATA 4E,0A
00720:  DATA 0D,00
00722:  DATA 49,6E
00724:  DATA 70,75
00726:  DATA 74,20
00728:  DATA 31,32
0072A:  DATA 2D,3E
0072C:  DATA 20,4F
0072E:  DATA 46,46
00730:  DATA 0A,0D
00732:  DATA 00,00
00734:  DATA 49,6E
00736:  DATA 70,75
00738:  DATA 74,20
0073A:  DATA 31,33
0073C:  DATA 2D,3E
0073E:  DATA 20,4F
00740:  DATA 4E,0A
00742:  DATA 0D,00
00744:  DATA 49,6E
00746:  DATA 70,75
00748:  DATA 74,20
0074A:  DATA 31,33
0074C:  DATA 2D,3E
0074E:  DATA 20,4F
00750:  DATA 46,46
00752:  DATA 0A,0D
00754:  DATA 00,00
00756:  DATA 49,6E
00758:  DATA 70,75
0075A:  DATA 74,20
0075C:  DATA 31,34
0075E:  DATA 2D,3E
00760:  DATA 20,4F
00762:  DATA 4E,0A
00764:  DATA 0D,00
00766:  DATA 49,6E
00768:  DATA 70,75
0076A:  DATA 74,20
0076C:  DATA 31,34
0076E:  DATA 2D,3E
00770:  DATA 20,4F
00772:  DATA 46,46
00774:  DATA 0A,0D
00776:  DATA 00,00
00778:  DATA 49,6E
0077A:  DATA 70,75
0077C:  DATA 74,20
0077E:  DATA 31,35
00780:  DATA 2D,3E
00782:  DATA 20,4F
00784:  DATA 4E,0A
00786:  DATA 0D,00
00788:  DATA 49,6E
0078A:  DATA 70,75
0078C:  DATA 74,20
0078E:  DATA 31,35
00790:  DATA 2D,3E
00792:  DATA 20,4F
00794:  DATA 46,46
00796:  DATA 0A,0D
00798:  DATA 00,00
0079A:  DATA 49,6E
0079C:  DATA 70,75
0079E:  DATA 74,20
007A0:  DATA 31,36
007A2:  DATA 2D,3E
007A4:  DATA 20,4F
007A6:  DATA 4E,0A
007A8:  DATA 0D,00
007AA:  DATA 49,6E
007AC:  DATA 70,75
007AE:  DATA 74,20
007B0:  DATA 31,36
007B2:  DATA 2D,3E
007B4:  DATA 20,4F
007B6:  DATA 46,46
007B8:  DATA 0A,0D
007BA:  DATA 00,00
007BC:  DATA 49,6E
007BE:  DATA 69,63
007C0:  DATA 69,6F
007C2:  DATA 20,64
007C4:  DATA 65,20
007C6:  DATA 46,75
007C8:  DATA 6E,63
007CA:  DATA 69,6F
007CC:  DATA 6E,61
007CE:  DATA 6D,65
007D0:  DATA 6E,74
007D2:  DATA 6F,20
007D4:  DATA 4F,4B
007D6:  DATA 0A,0D
007D8:  DATA 00,00
007DA:  DATA 53,54
007DC:  DATA 45,50
007DE:  DATA 3D,25
007E0:  DATA 75,0A
007E2:  DATA 0D,00
007E4:  DATA 49,6E
007E6:  DATA 74,65
007E8:  DATA 72,66
007EA:  DATA 6F,6E
007EC:  DATA 69,61
007EE:  DATA 20,2D
007F0:  DATA 20,4E
007F2:  DATA 6F,69
007F4:  DATA 74,65
007F6:  DATA 2E,20
007F8:  DATA 41,62
007FA:  DATA 72,69
007FC:  DATA 72,20
007FE:  DATA 42,61
00800:  DATA 72,72
00802:  DATA 65,69
00804:  DATA 72,61
00806:  DATA 2C,20
00808:  DATA 50,6F
0080A:  DATA 72,74
0080C:  DATA E3,6F
0080E:  DATA 20,50
00810:  DATA 30,20
00812:  DATA 65,20
00814:  DATA 50,6F
00816:  DATA 72,74
00818:  DATA 61,6F
0081A:  DATA 20,52
0081C:  DATA 45,53
0081E:  DATA 2E,00
00820:  DATA 56,6F
00822:  DATA 75,20
00824:  DATA 63,61
00826:  DATA 72,72
00828:  DATA 65,67
0082A:  DATA 61,72
0082C:  DATA 20,6F
0082E:  DATA 20,54
00830:  DATA 69,6D
00832:  DATA 65,72
00834:  DATA 47,31
00836:  DATA 33,00
00838:  DATA 4E,20
0083A:  DATA 52,65
0083C:  DATA 73,69
0083E:  DATA 64,65
00840:  DATA 6E,74
00842:  DATA 65,2E
00844:  DATA 20,41
00846:  DATA 62,72
00848:  DATA 69,72
0084A:  DATA 20,42
0084C:  DATA 61,72
0084E:  DATA 72,65
00850:  DATA 69,72
00852:  DATA 61,73
00854:  DATA 2E,00
00856:  DATA 43,61
00858:  DATA 72,72
0085A:  DATA 65,67
0085C:  DATA 61,72
0085E:  DATA 20,54
00860:  DATA 69,6D
00862:  DATA 65,72
00864:  DATA 47,31
00866:  DATA 32,00
00868:  DATA 52,65
0086A:  DATA 73,69
0086C:  DATA 64,65
0086E:  DATA 6E,74
00870:  DATA 65,2E
00872:  DATA 20,41
00874:  DATA 62,72
00876:  DATA 69,72
00878:  DATA 20,42
0087A:  DATA 61,72
0087C:  DATA 72,65
0087E:  DATA 69,72
00880:  DATA 61,20
00882:  DATA 65,20
00884:  DATA 50,6F
00886:  DATA 72,74
00888:  DATA 61,6F
0088A:  DATA 20,52
0088C:  DATA 45,53
0088E:  DATA 2E,00
00890:  DATA 56,6F
00892:  DATA 75,20
00894:  DATA 63,61
00896:  DATA 72,72
00898:  DATA 65,67
0089A:  DATA 61,72
0089C:  DATA 20,6F
0089E:  DATA 20,54
008A0:  DATA 69,6D
008A2:  DATA 65,72
008A4:  DATA 47,31
008A6:  DATA 33,00
008A8:  DATA 43,68
008AA:  DATA 61,6D
008AC:  DATA 61,64
008AE:  DATA 61,20
008B0:  DATA 49,31
008B2:  DATA 2C,20
008B4:  DATA 42,6C
008B6:  DATA 6F,71
008B8:  DATA 75,65
008BA:  DATA 65,69
008BC:  DATA 00,00
008BE:  DATA 43,68
008C0:  DATA 61,6D
008C2:  DATA 61,64
008C4:  DATA 61,20
008C6:  DATA 49,31
008C8:  DATA 20,53
008CA:  DATA 61,69
008CC:  DATA 75,2C
008CE:  DATA 20,44
008D0:  DATA 65,73
008D2:  DATA 6C,6F
008D4:  DATA 71,75
008D6:  DATA 65,65
008D8:  DATA 69,00
008DA:  DATA 43,68
008DC:  DATA 61,6D
008DE:  DATA 61,64
008E0:  DATA 61,20
008E2:  DATA 49,31
008E4:  DATA 2C,20
008E6:  DATA 42,6C
008E8:  DATA 6F,71
008EA:  DATA 75,65
008EC:  DATA 65,69
008EE:  DATA 00,00
008F0:  DATA 43,68
008F2:  DATA 61,6D
008F4:  DATA 61,64
008F6:  DATA 61,20
008F8:  DATA 49,31
008FA:  DATA 20,53
008FC:  DATA 61,69
008FE:  DATA 75,2C
00900:  DATA 20,44
00902:  DATA 65,73
00904:  DATA 6C,6F
00906:  DATA 71,75
00908:  DATA 65,65
0090A:  DATA 69,00
0090C:  DATA 50,75
0090E:  DATA 6C,73
00910:  DATA 6F,20
00912:  DATA 62,61
00914:  DATA 72,72
00916:  DATA 65,69
00918:  DATA 72,61
0091A:  DATA 20,64
0091C:  DATA 65,20
0091E:  DATA 65,6E
00920:  DATA 74,72
00922:  DATA 61,64
00924:  DATA 61,00
00926:  DATA 50,75
00928:  DATA 6C,73
0092A:  DATA 6F,20
0092C:  DATA 62,61
0092E:  DATA 72,72
00930:  DATA 65,69
00932:  DATA 72,61
00934:  DATA 20,61
00936:  DATA 75,78
00938:  DATA 69,6C
0093A:  DATA 69,61
0093C:  DATA 72,2E
0093E:  DATA 00,00
00940:  DATA 50,75
00942:  DATA 6C,73
00944:  DATA 6F,20
00946:  DATA 70,6F
00948:  DATA 72,74
0094A:  DATA 61,6F
0094C:  DATA 20,65
0094E:  DATA 6E,74
00950:  DATA 2E,00
00952:  DATA 50,75
00954:  DATA 6C,73
00956:  DATA 6F,20
00958:  DATA 70,6F
0095A:  DATA 72,74
0095C:  DATA 61,6F
0095E:  DATA 20,72
00960:  DATA 65,73
00962:  DATA 2E,00
*
009B4:  TBLRD*+
009B6:  MOVF   FF5,F
009B8:  BZ    09DE
009BA:  MOVFF  FF6,115
009BE:  MOVFF  FF7,116
009C2:  MOVFF  FF8,117
009C6:  MOVF   FF5,W
009C8:  CLRWDT
009CA:  BTFSS  FA4.4
009CC:  BRA    09C8
009CE:  MOVWF  F6D
009D0:  MOVFF  115,FF6
009D4:  MOVFF  116,FF7
009D8:  MOVFF  117,FF8
009DC:  BRA    09B4
009DE:  RETURN 0
*
00AD6:  MOVLB  1
00AD8:  MOVF   x22,W
00ADA:  MULWF  x24
00ADC:  MOVFF  FF3,01
00AE0:  MOVFF  FF4,00
00AE4:  MULWF  x25
00AE6:  MOVF   FF3,W
00AE8:  ADDWF  00,F
00AEA:  MOVF   x23,W
00AEC:  MULWF  x24
00AEE:  MOVF   FF3,W
00AF0:  ADDWFC 00,W
00AF2:  MOVWF  02
00AF4:  MOVLB  0
00AF6:  RETURN 0
*
00DEC:  TBLRD*+
00DEE:  MOVFF  FF6,116
00DF2:  MOVFF  FF7,117
00DF6:  MOVFF  FF8,118
00DFA:  MOVF   FF5,W
00DFC:  CLRWDT
00DFE:  BTFSS  FA4.4
00E00:  BRA    0DFC
00E02:  MOVWF  F6D
00E04:  MOVFF  116,FF6
00E08:  MOVFF  117,FF7
00E0C:  MOVFF  118,FF8
00E10:  MOVLB  1
00E12:  DECFSZ x15,F
00E14:  BRA    0E18
00E16:  BRA    0E1C
00E18:  MOVLB  0
00E1A:  BRA    0DEC
00E1C:  MOVLB  0
00E1E:  RETURN 0
00E20:  MOVLB  1
00E22:  MOVF   x18,W
00E24:  CLRF   01
00E26:  SUBWF  x17,W
00E28:  BC    0E30
00E2A:  MOVFF  117,00
00E2E:  BRA    0E48
00E30:  CLRF   00
00E32:  MOVLW  08
00E34:  MOVWF  x19
00E36:  RLCF   x17,F
00E38:  RLCF   00,F
00E3A:  MOVF   x18,W
00E3C:  SUBWF  00,W
00E3E:  BTFSC  FD8.0
00E40:  MOVWF  00
00E42:  RLCF   01,F
00E44:  DECFSZ x19,F
00E46:  BRA    0E36
00E48:  MOVLB  0
00E4A:  RETURN 0
00E4C:  MOVF   01,W
00E4E:  MOVFF  115,117
00E52:  MOVLW  64
00E54:  MOVLB  1
00E56:  MOVWF  x18
00E58:  MOVLB  0
00E5A:  RCALL  0E20
00E5C:  MOVFF  00,115
00E60:  MOVF   01,W
00E62:  MOVLW  30
00E64:  BNZ   0E76
00E66:  MOVLB  1
00E68:  BTFSS  x16.1
00E6A:  BRA    0E8A
00E6C:  BTFSC  x16.3
00E6E:  BRA    0E8A
00E70:  BTFSC  x16.4
00E72:  MOVLW  20
00E74:  BRA    0E7E
00E76:  MOVLB  1
00E78:  BCF    x16.3
00E7A:  BCF    x16.4
00E7C:  BSF    x16.0
00E7E:  ADDWF  01,F
00E80:  MOVF   01,W
00E82:  CLRWDT
00E84:  BTFSS  FA4.4
00E86:  BRA    0E82
00E88:  MOVWF  F6D
00E8A:  MOVFF  115,117
00E8E:  MOVLW  0A
00E90:  MOVWF  x18
00E92:  MOVLB  0
00E94:  RCALL  0E20
00E96:  MOVFF  00,115
00E9A:  MOVF   01,W
00E9C:  MOVLW  30
00E9E:  BNZ   0EB0
00EA0:  MOVLB  1
00EA2:  BTFSC  x16.3
00EA4:  BRA    0EBE
00EA6:  BTFSS  x16.0
00EA8:  BRA    0EBE
00EAA:  BTFSC  x16.4
00EAC:  MOVLW  20
00EAE:  MOVLB  0
00EB0:  ADDWF  01,F
00EB2:  MOVF   01,W
00EB4:  CLRWDT
00EB6:  BTFSS  FA4.4
00EB8:  BRA    0EB4
00EBA:  MOVWF  F6D
00EBC:  MOVLB  1
00EBE:  MOVLW  30
00EC0:  ADDWF  x15,F
00EC2:  MOVF   x15,W
00EC4:  CLRWDT
00EC6:  BTFSS  FA4.4
00EC8:  BRA    0EC4
00ECA:  MOVWF  F6D
00ECC:  MOVLB  0
00ECE:  RETURN 0
00ED0:  MOVF   FEF,F
00ED2:  BZ    0EF6
00ED4:  MOVFF  FEA,116
00ED8:  MOVFF  FE9,115
00EDC:  MOVF   FEF,W
00EDE:  CLRWDT
00EE0:  BTFSS  FA4.4
00EE2:  BRA    0EDE
00EE4:  MOVWF  F6D
00EE6:  MOVFF  116,FEA
00EEA:  MOVFF  115,FE9
00EEE:  INCF   FE9,F
00EF0:  BTFSC  FD8.2
00EF2:  INCF   FEA,F
00EF4:  BRA    0ED0
00EF6:  RETURN 0
*
01C38:  ADDWF  FE8,W
01C3A:  CLRF   FF7
01C3C:  RLCF   FF7,F
01C3E:  ADDLW  59
01C40:  MOVWF  FF6
01C42:  MOVLW  1C
01C44:  ADDWFC FF7,F
01C46:  MOVLW  00
01C48:  MOVWF  FF8
01C4A:  MOVWF  FFB
01C4C:  TBLRD*-
01C4E:  MOVF   FF5,W
01C50:  MOVWF  FFA
01C52:  TBLRD*
01C54:  MOVF   FF5,W
01C56:  MOVWF  FF9
01C58:  DATA 50,10
01C5A:  DATA 34,1C
01C5C:  DATA 34,1C
01C5E:  DATA 34,1C
01C60:  DATA 34,1C
01C62:  DATA 34,1C
01C64:  DATA 34,1C
01C66:  DATA 34,1C
01C68:  DATA 34,1C
01C6A:  DATA 34,1C
01C6C:  DATA 34,1C
01C6E:  DATA 34,1C
01C70:  DATA 34,1C
01C72:  DATA 34,1C
01C74:  DATA 34,1C
01C76:  DATA 34,1C
01C78:  DATA 34,1C
01C7A:  DATA 34,1C
01C7C:  DATA 34,1C
01C7E:  DATA 34,1C
01C80:  DATA 34,1C
01C82:  DATA 34,1C
01C84:  DATA 34,1C
01C86:  DATA 34,1C
01C88:  DATA 34,1C
01C8A:  DATA 34,1C
01C8C:  DATA 34,1C
01C8E:  DATA 34,1C
01C90:  DATA 34,1C
01C92:  DATA 34,1C
01C94:  DATA 86,10
01C96:  DATA A4,10
01C98:  DATA C4,10
01C9A:  DATA E4,10
01C9C:  DATA 04,11
01C9E:  DATA 24,11
01CA0:  DATA 44,11
01CA2:  DATA 64,11
01CA4:  DATA 84,11
01CA6:  DATA A4,11
01CA8:  DATA C4,11
01CAA:  DATA E4,11
01CAC:  DATA 04,12
01CAE:  DATA 24,12
01CB0:  DATA 44,12
01CB2:  DATA 64,12
01CB4:  DATA 82,12
01CB6:  DATA 86,12
01CB8:  DATA 90,12
01CBA:  DATA 34,1C
01CBC:  DATA 34,1C
01CBE:  DATA AA,18
01CC0:  DATA 34,1C
01CC2:  DATA 34,1C
01CC4:  DATA 34,1C
01CC6:  DATA 34,1C
01CC8:  DATA 34,1C
01CCA:  DATA 34,1C
01CCC:  DATA 34,1C
01CCE:  DATA 34,1C
01CD0:  DATA 34,1C
01CD2:  DATA 34,1C
01CD4:  DATA DA,18
01CD6:  DATA FE,18
01CD8:  DATA 22,19
01CDA:  DATA 50,19
01CDC:  DATA EE,1A
*
02FD2:  ADDWF  FE8,W
02FD4:  CLRF   FF7
02FD6:  RLCF   FF7,F
02FD8:  ADDLW  F3
02FDA:  MOVWF  FF6
02FDC:  MOVLW  2F
02FDE:  ADDWFC FF7,F
02FE0:  MOVLW  00
02FE2:  MOVWF  FF8
02FE4:  MOVWF  FFB
02FE6:  TBLRD*-
02FE8:  MOVF   FF5,W
02FEA:  MOVWF  FFA
02FEC:  TBLRD*
02FEE:  MOVF   FF5,W
02FF0:  MOVWF  FF9
02FF2:  DATA 50,2C
02FF4:  DATA 6C,2C
02FF6:  DATA C4,2C
02FF8:  DATA 54,2D
02FFA:  DATA 70,2D
02FFC:  DATA B8,2D
02FFE:  DATA 4A,2E
03000:  DATA 66,2E
03002:  DATA A0,2E
....................  
.................... #list 
....................  
.................... #fuses HS,PROTECT,NOETHLED,WDT8192 
.................... #use delay(clock=25000000) 
*
00964:  MOVLW  01
00966:  MOVWF  FEA
00968:  MOVLW  29
0096A:  MOVWF  FE9
0096C:  MOVF   FEF,W
0096E:  BZ    098C
00970:  MOVLW  08
00972:  MOVWF  01
00974:  CLRF   00
00976:  DECFSZ 00,F
00978:  BRA    0976
0097A:  DECFSZ 01,F
0097C:  BRA    0974
0097E:  MOVLW  19
00980:  MOVWF  00
00982:  DECFSZ 00,F
00984:  BRA    0982
00986:  BRA    0988
00988:  DECFSZ FEF,F
0098A:  BRA    0970
0098C:  RETURN 0
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(D) 
.................... #use fast_io(E)                      //Saídas Relé 2-9 
.................... #use fast_io(F)                      //Entradas analógicas e outputs especiais 
.................... #use fast_io(H)                      //Entradas DipSwitch 
.................... #use fast_io(J)                    //Display LCD+ botoes 
....................   
.................... #use standard_io(C)        //Mosfet, 
.................... #use standard_io(G)        //Mosfet,  
....................  
.................... #use RS232(UART2, baud=19200, xmit=PIN_G1, rcv=PIN_G2, errors, stream=PORT2,RESTART_WDT)                     
*
000CA:  CLRWDT
000CC:  BTFSS  FA4.5
000CE:  BRA    00CA
000D0:  MOVFF  F6B,1B
000D4:  MOVFF  F6E,01
000D8:  BTFSS  1B.1
000DA:  BRA    00E0
000DC:  BCF    F6B.4
000DE:  BSF    F6B.4
000E0:  GOTO   00E6 (RETURN)
*
00B6C:  CLRWDT
00B6E:  BTFSS  FA4.4
00B70:  BRA    0B6C
00B72:  MOVWF  F6D
00B74:  RETURN 0
....................  
....................   //RS232 
.................... #use I2C(master, sda=PIN_C4, scl=PIN_C3)  //C4 bidi, C3 out 
*
00EF8:  BCF    FC6.7
00EFA:  BCF    F9E.3
00EFC:  MOVFF  11D,FC9
00F00:  MOVLW  02
00F02:  BTFSC  FC6.7
00F04:  BRA    0F10
00F06:  BTFSS  F9E.3
00F08:  BRA    0F06
00F0A:  MOVLW  00
00F0C:  BTFSC  FC5.6
00F0E:  MOVLW  01
00F10:  MOVWF  01
00F12:  RETURN 0
*
00FEC:  BCF    FC6.6
00FEE:  BSF    FC5.3
00FF0:  BTFSC  FC5.3
00FF2:  BRA    0FF0
00FF4:  BTFSC  00.0
00FF6:  BCF    FC5.5
00FF8:  BTFSS  00.0
00FFA:  BSF    FC5.5
00FFC:  BSF    FC5.4
00FFE:  BTFSC  FC5.4
01000:  BRA    0FFE
01002:  MOVFF  FC9,01
01006:  RETURN 0
....................  
....................  
.................... #define LCD_DB4   PIN_J4         //  PIN_J4 
.................... #define LCD_DB5   PIN_J5         //  PIN_J5 
.................... #define LCD_DB6   PIN_J6         //  PIN_J6 
.................... #define LCD_DB7   PIN_J7         //  PIN_J7 
....................  
.................... #define LCD_RS    PIN_G7         //  PIN_G7 
.................... #define LCD_RW    PIN_G6         //  PIN_C0 
.................... #define LCD_E     PIN_G5         //  PIN_A5 
....................  
.................... #define ButtonM   PIN_J3         //  PIN_J3 
.................... #define ButtonInc PIN_J0         //  PIN_J2 
.................... #define ButtonDec PIN_J1         //  PIN_J0 
....................  
....................  
.................... #define IN1   PIN_B1        //Entrada Digital 0 -  
.................... #define IN2   PIN_B2        //Entrada Digital 1 -  
.................... #define IN3   PIN_D1        //Entrada Digital 2 -  
.................... #define IN4   PIN_D2        //Entrada Digital 3 -  
.................... #define IN5   PIN_D3        //Entrada Digital 4 -  
.................... #define IN6   PIN_B3        //Entrada Digital 5 -  
.................... #define IN7   PIN_B4        //Entrada Digital 6 -  
.................... #define IN8   PIN_B5        //Entrada Digital 7 -  
....................  
.................... #define IN9   PIN_A2        //Entrada Digital(Analog) 0 -  
.................... #define IN10  PIN_A5        //Entrada Digital(Analog) 1 -  
.................... #define IN11  PIN_F0        //Entrada Digital(Analog) 2 -    
.................... #define IN12  PIN_F5        //Entrada Digital(Analog) 3 -  
.................... #define IN13  PIN_F4        //Entrada Digital(Analog) 4 -  
.................... #define IN14  PIN_F3        //Entrada Digital(Analog) 5 -  
.................... #define IN15  PIN_F2        //Entrada Digital(Analog) 6 -  
.................... #define IN16  PIN_F1        //Entrada Digital(Analog) 7 -  
....................  
....................  
....................  
.................... /* 
.................... #define OUT_SS1   PIN_E2        //Saída Relé 2 - Semáforo Saída Piso -1  (0->RED, 1->GREEN) 
.................... #define OUT_SS2   PIN_E3        //Saída Relé 3 - Semáforo Saída Piso -2  (0->RED, 1->GREEN)  
.................... #define OUT_SS3   PIN_E4        //Saída Relé 4 - Semáforo Saída Piso -3  (0->RED, 1->GREEN)  
.................... #define OUT_SE    PIN_E5        //Saída Relé 5 - Semáforo Entrada Parque (0->RED, 1->GREEN)  
.................... #define OUT_SD    PIN_E6        //Saída Relé 6 - Semáforo Entrada Piso -3(0->RED, 1->GREEN)  
.................... #define OUT_ME    PIN_E7        //Saída Relé 7 - Sinal Desactivação Máquina Entrada(1->OFF)  
.................... #define OUT_MS    PIN_B0        //Saída Relé 8 - Sinal Desactivação Máquina Entrada(1->OFF)  
.................... */ 
....................  
....................  
....................  
....................  
....................  
.................... #include <25LC1024.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////    //Libraria alterada por Victor Andrade (SPI 2) 
....................  
.................... /// Library for a MicroChip 93C56 configured for a x8 org           //// 
.................... ////   Uses hardware SSP unit.                                         //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #define EEPROM_SELECT PIN_D7       //Chip Select SPI2 
.................... #define EEPROM_DI     PIN_D5 
.................... #define EEPROM_DO     PIN_D4 
.................... #define EEPROM_CLK    PIN_D6 
....................  
....................  
.................... #define EEPROM_ADDRESS unsigned int32      //Atenção esta memória têm endereço até 24Bits        
.................... #define EEPROM_SIZE    131072              //Espaço da memória 
....................  
....................  
.................... //Verificar se a eeprom está pronta para escrita ou leitura 
.................... int1 ext_eeprom_ready(void)  
.................... {  
....................  int8 data; 
....................  
....................  output_low(EEPROM_SELECT); // CS = 0  
*
009E0:  BCF    F8C.7
....................  spi_write2(0x05);             //Lê registo do estado da memória 
009E2:  MOVF   F66,W
009E4:  MOVLW  05
009E6:  MOVWF  F66
009E8:  RRCF   F64,W
009EA:  BNC   09E8
....................  data = spi_read2(0); 
009EC:  MOVF   F66,W
009EE:  CLRF   F66
009F0:  RRCF   F64,W
009F2:  BNC   09F0
009F4:  MOVFF  F66,128
.................... // fprintf(PORT2,"Data do eeprom ready %X\n\r",data); 
....................  output_high(EEPROM_SELECT); // CS = 1 
009F8:  BSF    F8C.7
....................  delay_ms(2);                //acrescentei 
009FA:  MOVLW  02
009FC:  MOVLB  1
009FE:  MOVWF  x29
00A00:  MOVLB  0
00A02:  RCALL  0964
....................  return(!bit_test(data, 0));    // 
00A04:  MOVLW  00
00A06:  MOVLB  1
00A08:  BTFSS  x28.0
00A0A:  MOVLW  01
00A0C:  MOVWF  01
00A0E:  MOVLB  0
00A10:  RETURN 0
.................... } 
....................   
....................  
.................... //Escreve dados 8 bits na eeprom SPI 
....................  
....................  void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
....................  {  
....................  // fprintf(PORT2,"Inicio de Escrita\n\r"); 
....................   while(!ext_eeprom_ready());   // 
*
00AF8:  RCALL  09E0
00AFA:  MOVF   01,F
00AFC:  BZ    0AF8
....................  // fprintf(PORT2,"EEPROM PRONTA\n\r"); 
....................   output_low(EEPROM_SELECT);   // CS = 0  
00AFE:  BCF    F8C.7
....................   spi_write2(0x06);             //Habilita escrita em memória WREN 
00B00:  MOVF   F66,W
00B02:  MOVLW  06
00B04:  MOVWF  F66
00B06:  RRCF   F64,W
00B08:  BNC   0B06
....................   output_high(EEPROM_SELECT); // CS = 1  
00B0A:  BSF    F8C.7
....................   delay_ms(2);                //Acrescentei  
00B0C:  MOVLW  02
00B0E:  MOVLB  1
00B10:  MOVWF  x29
00B12:  MOVLB  0
00B14:  RCALL  0964
....................   output_low(EEPROM_SELECT); // CS = 0 
00B16:  BCF    F8C.7
....................   spi_write2(0x02); //Modo de Escrita 
00B18:  MOVF   F66,W
00B1A:  MOVLW  02
00B1C:  MOVWF  F66
00B1E:  RRCF   F64,W
00B20:  BNC   0B1E
....................   spi_write2(address >> 16); // Envia os 8bits iniciais mais significativo (dos 24bits) 
00B22:  MOVFF  125,129
00B26:  MOVFF  126,12A
00B2A:  MOVLB  1
00B2C:  CLRF   x2B
00B2E:  CLRF   x2C
00B30:  MOVF   F66,W
00B32:  MOVFF  125,F66
00B36:  RRCF   F64,W
00B38:  BNC   0B36
....................   spi_write2(address >> 8); // Envia o endereço 8bits intermedio 
00B3A:  MOVFF  124,129
00B3E:  MOVFF  125,12A
00B42:  MOVFF  126,12B
00B46:  CLRF   x2C
00B48:  MOVF   F66,W
00B4A:  MOVFF  124,F66
00B4E:  RRCF   F64,W
00B50:  BNC   0B4E
....................   spi_write2(address);          // Envia o menos significativo 
00B52:  MOVF   F66,W
00B54:  MOVFF  123,F66
00B58:  RRCF   F64,W
00B5A:  BNC   0B58
....................   spi_write2(data);             //Escreve em memória 
00B5C:  MOVF   F66,W
00B5E:  MOVFF  127,F66
00B62:  RRCF   F64,W
00B64:  BNC   0B62
....................   output_high(EEPROM_SELECT);   // CS = 1  
00B66:  BSF    F8C.7
00B68:  MOVLB  0
00B6A:  RETURN 0
....................  } 
....................  
....................  
....................  
.................... //LEITUTA DA EEPROM 
....................  
....................  BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
....................  {  
....................  int8 data;  
....................  //fprintf(PORT2,"Inicio de Leitura\n\r"); 
....................  while(!ext_eeprom_ready());  
*
00A12:  RCALL  09E0
00A14:  MOVF   01,F
00A16:  BZ    0A12
....................  //fprintf(PORT2,"EEPROM PRONTA\n\r"); 
....................  output_low(EEPROM_SELECT); // CS =0  
00A18:  BCF    F8C.7
....................  spi_write2(0x03);           //Modo Leitura 
00A1A:  MOVF   F66,W
00A1C:  MOVLW  03
00A1E:  MOVWF  F66
00A20:  RRCF   F64,W
00A22:  BNC   0A20
....................  spi_write2(address >> 16);  
00A24:  MOVFF  117,11B
00A28:  MOVFF  118,11C
00A2C:  MOVLB  1
00A2E:  CLRF   x1D
00A30:  CLRF   x1E
00A32:  MOVF   F66,W
00A34:  MOVFF  117,F66
00A38:  RRCF   F64,W
00A3A:  BNC   0A38
....................  spi_write2(address >> 8);  
00A3C:  MOVFF  116,11B
00A40:  MOVFF  117,11C
00A44:  MOVFF  118,11D
00A48:  CLRF   x1E
00A4A:  MOVF   F66,W
00A4C:  MOVFF  116,F66
00A50:  RRCF   F64,W
00A52:  BNC   0A50
....................  spi_write2(address);   
00A54:  MOVF   F66,W
00A56:  MOVFF  115,F66
00A5A:  RRCF   F64,W
00A5C:  BNC   0A5A
....................  
....................  data = spi_read2(0); //Ler dados de 8bits na memória 
00A5E:  MOVF   F66,W
00A60:  CLRF   F66
00A62:  RRCF   F64,W
00A64:  BNC   0A62
00A66:  MOVFF  F66,119
....................  output_high(EEPROM_SELECT); // CS = 1  
00A6A:  BSF    F8C.7
....................  
....................  return(data);  
00A6C:  MOVFF  119,01
00A70:  MOVLB  0
00A72:  RETURN 0
....................  } 
....................  
....................  
....................  
....................  
.................... #include <MK41T56.c> 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///               DRIVER  MK41T56.C   --> by Victor Andrade                  ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
....................  
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);   
.................... /*          //O MK não precissa de inicialização 
.................... void ds1307_init(void)        
.................... {  
....................    BYTE seconds = 0;  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_start();  
....................    i2c_write(0xD1);      // RD from RTC  
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
....................    i2c_stop();  
....................    seconds &= 0x7F;  
....................  
....................    delay_us(3);  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x07);      // Control Register  
....................    i2c_write(0x80);     // Disable squarewave output pin  
....................    i2c_stop();  
....................  
.................... }  
.................... */ 
.................... void mk41t56_set_date_time(BYTE year, BYTE mth, BYTE date, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... {  
....................   sec &= 0x7F;  
*
00F3C:  MOVLB  1
00F3E:  BCF    x1B.7
....................   hr &= 0x3F;  
00F40:  MOVLW  3F
00F42:  ANDWF  x19,F
....................   min &= 0x7F; 
00F44:  BCF    x1A.7
....................   dow &=0x07;  //day of week 
00F46:  MOVLW  07
00F48:  ANDWF  x18,F
....................   date &= 0x3F;  
00F4A:  MOVLW  3F
00F4C:  ANDWF  x17,F
....................   mth &= 0x1F; 
00F4E:  MOVLW  1F
00F50:  ANDWF  x16,F
....................    
....................   i2c_start();  
00F52:  BSF    FC5.0
00F54:  BTFSC  FC5.0
00F56:  BRA    0F54
....................   i2c_write(0b11010000);            // I2C write address 0xD0 
00F58:  MOVLW  D0
00F5A:  MOVWF  x1D
00F5C:  MOVLB  0
00F5E:  RCALL  0EF8
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
00F60:  MOVLB  1
00F62:  CLRF   x1D
00F64:  MOVLB  0
00F66:  RCALL  0EF8
....................   i2c_write(bin2bcd(sec));      // REG 0  
00F68:  MOVFF  11B,11C
00F6C:  RCALL  0F14
00F6E:  MOVFF  01,11C
00F72:  MOVFF  01,11D
00F76:  RCALL  0EF8
....................   i2c_write(bin2bcd(min));      // REG 1  
00F78:  MOVFF  11A,11C
00F7C:  RCALL  0F14
00F7E:  MOVFF  01,11C
00F82:  MOVFF  01,11D
00F86:  RCALL  0EF8
....................   i2c_write(bin2bcd(hr));      // REG 2  
00F88:  MOVFF  119,11C
00F8C:  RCALL  0F14
00F8E:  MOVFF  01,11C
00F92:  MOVFF  01,11D
00F96:  RCALL  0EF8
....................   i2c_write(bin2bcd(dow));      // REG 3  
00F98:  MOVFF  118,11C
00F9C:  RCALL  0F14
00F9E:  MOVFF  01,11C
00FA2:  MOVFF  01,11D
00FA6:  RCALL  0EF8
....................   i2c_write(bin2bcd(date));      // REG 4  
00FA8:  MOVFF  117,11C
00FAC:  RCALL  0F14
00FAE:  MOVFF  01,11C
00FB2:  MOVFF  01,11D
00FB6:  RCALL  0EF8
....................   i2c_write(bin2bcd(mth));      // REG 5  
00FB8:  MOVFF  116,11C
00FBC:  RCALL  0F14
00FBE:  MOVFF  01,11C
00FC2:  MOVFF  01,11D
00FC6:  RCALL  0EF8
....................   i2c_write(bin2bcd(year));      // REG 6  
00FC8:  MOVFF  115,11C
00FCC:  RCALL  0F14
00FCE:  MOVFF  01,11C
00FD2:  MOVFF  01,11D
00FD6:  RCALL  0EF8
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
00FD8:  MOVLW  80
00FDA:  MOVLB  1
00FDC:  MOVWF  x1D
00FDE:  MOVLB  0
00FE0:  RCALL  0EF8
....................   i2c_stop(); 
00FE2:  BSF    FC5.2
00FE4:  BTFSC  FC5.2
00FE6:  BRA    0FE4
00FE8:  GOTO   194E (RETURN)
.................... }  
....................  
.................... void mk41t56_get_date(BYTE &year, BYTE &mth ,BYTE &date, BYTE &dow)  
.................... {  
....................   i2c_start();  
*
0195C:  BSF    FC5.0
0195E:  BTFSC  FC5.0
01960:  BRA    195E
....................   i2c_write(0xD0);  
01962:  MOVLW  D0
01964:  MOVLB  1
01966:  MOVWF  x1D
01968:  MOVLB  0
0196A:  CALL   0EF8
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
0196E:  MOVLW  03
01970:  MOVLB  1
01972:  MOVWF  x1D
01974:  MOVLB  0
01976:  CALL   0EF8
....................   i2c_start();  
0197A:  BSF    FC5.1
0197C:  BTFSC  FC5.1
0197E:  BRA    197C
....................   i2c_write(0xD1);  
01980:  MOVLW  D1
01982:  MOVLB  1
01984:  MOVWF  x1D
01986:  MOVLB  0
01988:  CALL   0EF8
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
0198C:  MOVLW  01
0198E:  MOVWF  00
01990:  CALL   0FEC
01994:  MOVF   01,W
01996:  ANDLW  7F
01998:  MOVLB  1
0199A:  MOVWF  x15
0199C:  MOVWF  x1A
0199E:  MOVLB  0
019A0:  CALL   1008
019A4:  MOVFF  01,111
....................   date  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
019A8:  MOVLW  01
019AA:  MOVWF  00
019AC:  CALL   0FEC
019B0:  MOVF   01,W
019B2:  ANDLW  3F
019B4:  MOVLB  1
019B6:  MOVWF  x15
019B8:  MOVWF  x1A
019BA:  MOVLB  0
019BC:  CALL   1008
019C0:  MOVFF  01,110
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
019C4:  MOVLW  01
019C6:  MOVWF  00
019C8:  CALL   0FEC
019CC:  MOVF   01,W
019CE:  ANDLW  1F
019D0:  MOVLB  1
019D2:  MOVWF  x15
019D4:  MOVWF  x1A
019D6:  MOVLB  0
019D8:  CALL   1008
019DC:  MOVFF  01,10F
....................   year = bcd2bin(i2c_read(0));            // REG 6  
019E0:  CLRF   00
019E2:  CALL   0FEC
019E6:  MOVFF  01,115
019EA:  MOVFF  01,11A
019EE:  CALL   1008
019F2:  MOVFF  01,10E
....................   i2c_stop();  
019F6:  BSF    FC5.2
019F8:  BTFSC  FC5.2
019FA:  BRA    19F8
.................... }  
....................  
.................... void mk41t56_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   i2c_start();  
*
01AFA:  BSF    FC5.0
01AFC:  BTFSC  FC5.0
01AFE:  BRA    1AFC
....................   i2c_write(0xD0);  
01B00:  MOVLW  D0
01B02:  MOVLB  1
01B04:  MOVWF  x1D
01B06:  MOVLB  0
01B08:  CALL   0EF8
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
01B0C:  MOVLB  1
01B0E:  CLRF   x1D
01B10:  MOVLB  0
01B12:  CALL   0EF8
....................   i2c_start();  
01B16:  BSF    FC5.1
01B18:  BTFSC  FC5.1
01B1A:  BRA    1B18
....................   i2c_write(0xD1);  
01B1C:  MOVLW  D1
01B1E:  MOVLB  1
01B20:  MOVWF  x1D
01B22:  MOVLB  0
01B24:  CALL   0EF8
....................   sec = bcd2bin(i2c_read() & 0x7f);  
01B28:  MOVLW  01
01B2A:  MOVWF  00
01B2C:  CALL   0FEC
01B30:  MOVF   01,W
01B32:  ANDLW  7F
01B34:  MOVLB  1
01B36:  MOVWF  x15
01B38:  MOVWF  x1A
01B3A:  MOVLB  0
01B3C:  CALL   1008
01B40:  MOVFF  01,114
....................   min = bcd2bin(i2c_read() & 0x7f);  
01B44:  MOVLW  01
01B46:  MOVWF  00
01B48:  CALL   0FEC
01B4C:  MOVF   01,W
01B4E:  ANDLW  7F
01B50:  MOVLB  1
01B52:  MOVWF  x15
01B54:  MOVWF  x1A
01B56:  MOVLB  0
01B58:  CALL   1008
01B5C:  MOVFF  01,113
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
01B60:  CLRF   00
01B62:  CALL   0FEC
01B66:  MOVF   01,W
01B68:  ANDLW  3F
01B6A:  MOVLB  1
01B6C:  MOVWF  x15
01B6E:  MOVWF  x1A
01B70:  MOVLB  0
01B72:  CALL   1008
01B76:  MOVFF  01,112
....................   i2c_stop();  
01B7A:  BSF    FC5.2
01B7C:  BTFSC  FC5.2
01B7E:  BRA    1B7C
....................  
.................... }  
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................   BYTE temp;  
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
00F14:  MOVFF  11C,11D
....................   retval = 0;  
00F18:  MOVLB  1
00F1A:  CLRF   x1E
....................  
....................   while(1)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
00F1C:  MOVF   x1D,W
00F1E:  SUBLW  09
00F20:  BC    0F2C
....................     {  
....................       temp -= 10;  
00F22:  MOVLW  0A
00F24:  SUBWF  x1D,F
....................       retval += 0x10;  
00F26:  MOVLW  10
00F28:  ADDWF  x1E,F
....................     }  
00F2A:  BRA    0F32
....................     else // Get the ones digit by adding the remainder.  
....................     {  
....................       retval += temp;  
00F2C:  MOVF   x1D,W
00F2E:  ADDWF  x1E,F
....................       break;  
00F30:  BRA    0F34
....................     }  
00F32:  BRA    0F1C
....................   }  
....................  
....................   return(retval);  
00F34:  MOVFF  11E,01
00F38:  MOVLB  0
00F3A:  RETURN 0
.................... }  
....................  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp;  
....................  
....................   temp = bcd_value;  
*
01008:  MOVFF  11A,11B
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
0100C:  BCF    FD8.0
0100E:  MOVLB  1
01010:  RRCF   x1B,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
01012:  MOVLW  78
01014:  ANDWF  x1B,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f));  
01016:  RRCF   x1B,W
01018:  MOVWF  00
0101A:  RRCF   00,F
0101C:  MOVLW  3F
0101E:  ANDWF  00,F
01020:  MOVF   00,W
01022:  ADDWF  x1B,W
01024:  MOVWF  x1C
01026:  MOVF   x1A,W
01028:  ANDLW  0F
0102A:  ADDWF  x1C,W
0102C:  MOVWF  01
0102E:  MOVLB  0
01030:  RETURN 0
.................... }  
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <flex_lcd.c> 
.................... // flex_lcd.c 
....................  
.................... // These pins are for the Microchip PicDem2-Plus board, 
.................... // which is what I used to test the driver.  Change these 
.................... // pins to fit your own board. 
....................  
.................... //#define LCD_DB4   PIN_B4 
.................... //#define LCD_DB5   PIN_B5 
.................... //#define LCD_DB6   PIN_B6 
.................... //#define LCD_DB7   PIN_B7 
.................... // 
.................... //#define LCD_RS    PIN_C0 
.................... //#define LCD_RW    PIN_C1 
.................... //#define LCD_E     PIN_C2 
....................  
.................... // If you only want a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line. 
....................  
.................... #define USE_LCD_RW   1 
....................  
.................... //======================================== 
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
....................  
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression 
.................... // to a boolean (1 or 0). 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
....................  output_bit(LCD_DB6, !!(nibble & 4)); 
....................  output_bit(LCD_DB7, !!(nibble & 8)); 
....................  
....................  delay_cycles(1); 
....................  output_high(LCD_E); 
....................  delay_us(2); 
....................  output_low(LCD_E); 
.................... } 
....................  
.................... //----------------------------------- 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It's not a stand-alone routine.  For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... // Create bit variables so that we can easily set 
.................... // individual bits in the retval variable. 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
....................  
.................... retval = 0; 
.................... //Adicionei 
.................... SET_TRIS_J(0b11111101); //Set Tris do display 
....................  
.................... output_high(LCD_E); 
.................... delay_cycles(1); 
....................  
.................... retval_0 = input(LCD_DB4); 
.................... retval_1 = input(LCD_DB5); 
.................... retval_2 = input(LCD_DB6); 
.................... retval_3 = input(LCD_DB7); 
....................  
.................... output_low(LCD_E); 
....................  
.................... //Adicionei 
.................... SET_TRIS_J(0b00001111); //Set Tris do display 
....................  
.................... return(retval); 
.................... } 
.................... #endif 
....................  
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_byte(void) 
.................... { 
.................... int8 low; 
.................... int8 high; 
....................  
.................... output_high(LCD_RW); 
.................... delay_cycles(1); 
....................  
.................... high = lcd_read_nibble(); 
....................  
.................... low = lcd_read_nibble(); 
....................  
.................... return( (high<<4) | low); 
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... output_low(LCD_RS); 
....................  
.................... #ifdef USE_LCD_RW 
.................... while(bit_test(lcd_read_byte(),7)) ; 
.................... #else 
.................... delay_us(60); 
.................... #endif 
....................  
.................... if(address) 
....................    output_high(LCD_RS); 
.................... else 
....................    output_low(LCD_RS); 
....................  
....................  delay_cycles(1); 
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
.................... delay_cycles(1); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
....................  
.................... lcd_send_nibble(n >> 4); 
.................... lcd_send_nibble(n & 0xf); 
.................... } 
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... output_low(LCD_RS); 
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
....................  
.................... delay_ms(15); 
....................  
.................... for(i=0 ;i < 3; i++) 
....................    { 
....................     lcd_send_nibble(0x03); 
....................     delay_ms(5); 
....................    } 
....................  
.................... lcd_send_nibble(0x02); 
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
....................  
....................     // If the R/W signal is not used, then 
....................     // the busy bit can't be polled.  One of 
....................     // the init commands takes longer than 
....................     // the hard-coded delay of 60 us, so in 
....................     // that case, lets just do a 5 ms delay 
....................     // after all four of them. 
....................     #ifndef USE_LCD_RW 
....................     delay_ms(5); 
....................     #endif 
....................    } 
....................  
.................... } 
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
.................... if(y != 1) 
....................    address = lcd_line_two; 
.................... else 
....................    address=0; 
....................  
.................... address += x-1; 
.................... lcd_send_byte(0, 0x80 | address); 
.................... } 
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
....................     case '\f': 
....................       lcd_send_byte(0,1); 
....................       delay_ms(2); 
....................       break; 
....................  
....................     case '\n': 
....................        lcd_gotoxy(1,2); 
....................        break; 
....................  
....................     case '\b': 
....................        lcd_send_byte(0,0x10); 
....................        break; 
....................  
....................     default: 
....................        lcd_send_byte(1,c); 
....................        break; 
....................    } 
.................... } 
....................  
.................... //------------------------------ 
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7)); 
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(lcd_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
.................... void lcd_setcursor_vb(short visible, short blink) {  
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink);  
.................... }  
....................  
....................  
....................  
....................  
.................... //   ---------------------------------------------------- 
.................... char description[35]="SW uPLC Continente Bocage - LX\r\n"; 
.................... char version[20]="Versao V0.8\r\n"; 
.................... char datasw[15]="25-05-17\r\n"; 
....................  
.................... //   ---------------------------------------------------- 
....................  
....................  
.................... int16 TimerI1on=0,TimerI1off=0;    //Timer 5ms 
.................... int16 TimerI2on=0,TimerI2off=0;    //Timer 5ms 
.................... int16 TimerI3on=0,TimerI3off=0;    //Timer 5ms 
.................... int16 TimerI4on=0,TimerI4off=0;    //Timer 5ms 
.................... int16 TimerI5on=0,TimerI5off=0;    //Timer 5ms 
.................... int16 TimerI6on=0,TimerI6off=0;    //Timer 5ms 
.................... int16 TimerI7on=0,TimerI7off=0;    //Timer 5ms 
.................... int16 TimerI8on=0,TimerI8off=0;    //Timer 5ms 
....................  
.................... int16 TimerI9on=0,TimerI9off=0;      //Timer 5ms 
.................... int16 TimerI10on=0,TimerI10off=0;    //Timer 5ms 
.................... int16 TimerI11on=0,TimerI11off=0;    //Timer 5ms 
.................... int16 TimerI12on=0,TimerI12off=0;    //Timer 5ms 
.................... int16 TimerI13on=0,TimerI13off=0;    //Timer 5ms 
.................... int16 TimerI14on=0,TimerI14off=0;    //Timer 5ms 
.................... int16 TimerI15on=0,TimerI15off=0;    //Timer 5ms 
.................... int16 TimerI16on=0,TimerI16off=0;    //Timer 5ms 
....................  
....................  
....................  
....................  
.................... int8 auxI1on=0,auxI1off=0; 
.................... int8 auxI2on=0,auxI2off=0; 
.................... int8 auxI3on=0,auxI3off=0; 
.................... int8 auxI4on=0,auxI4off=0; 
.................... int8 auxI5on=0,auxI5off=0; 
.................... int8 auxI6on=0,auxI6off=0; 
.................... int8 auxI7on=0,auxI7off=0; 
.................... int8 auxI8on=0,auxI8off=0; 
....................  
.................... int8 auxI9on=0,auxI9off=0; 
.................... int8 auxI10on=0,auxI10off=0; 
.................... int8 auxI11on=0,auxI11off=0; 
.................... int8 auxI12on=0,auxI12off=0; 
.................... int8 auxI13on=0,auxI13off=0; 
.................... int8 auxI14on=0,auxI14off=0; 
.................... int8 auxI15on=0,auxI15off=0; 
.................... int8 auxI16on=0,auxI16off=0; 
....................  
....................  
.................... int1 ING_I1=0,ING_I2=0,ING_I3=0,ING_I4=0,ING_I5=0,ING_I6=0,ING_I7=0,ING_I8=0; 
.................... int1 MEM_I1=0,MEM_I2=0,MEM_I3=0,MEM_I4=0,MEM_I5=0,MEM_I6=0,MEM_I7=0,MEM_I8=0; 
.................... int1 ING_I9=0,ING_I10=0,ING_I11=0,ING_I12=0,ING_I13=0,ING_I14=0,ING_I15=0,ING_I16=0; 
.................... int1 MEM_I9=0,MEM_I10=0,MEM_I11=0,MEM_I12=0,MEM_I13=0,MEM_I14=0,MEM_I15=0,MEM_I16=0; 
.................... int8 data_receive=0; 
.................... Unsigned int8 Data_Buffer[7];    //era 6 
.................... int8 current_data=0; 
.................... int1 Carriage_Return=1; 
.................... int1 BufferOK=0; 
.................... int1 LinhaComando=0;           //0-> OFF, modo rádio activo, 1-> ON com linha de comandos 
....................  
....................  
....................  
.................... int8 count_TimerA=0; 
.................... int8 count_TimerB=0; // Contador p/Timer dos Pulsos 
.................... int8 count_TimerC=0; 
.................... int8 count_TimerD=0; 
.................... int8 count_TimerE=0; 
....................  
.................... int8 TIMER_A=0; 
.................... int8 TIMER_B=0;             // Timer p/Pulsos 
.................... int8 TIMER_C=0;             // Timer p/Pulsos 
.................... int8 TIMER_D=0;             // Timer p/Pulsos 
.................... int8 TIMER_E=0;             // Timer p/Pulsos 
....................  
....................  
.................... int8 TIMER_G12=0;          //timer limpeza G1 -> G2 
.................... int8 TIMER_G13=0;          //timer limpeza G1 -> G3 
....................  
.................... int1 SIGNAL_BLINK=0; 
....................  
....................  
....................  
.................... Unsigned int8 Tempos[25]; 
....................  
.................... int8 EstadoG1=0;  //0: Verde, 1:Vermelho 
.................... int8 EstadoG2=0;  //0: Verde, 1:Vermelho 
.................... int8 EstadoG3=0;  //0: Verde, 1:Vermelho 
....................  
.................... int8 step=0; 
....................  
.................... int1 debug=0,debugInputs=0; 
.................... int1 flagEstadoME=0,flagEstadoMS=0;  //1-> Máquina Ativada 
.................... int1 flag_maqAtiva=0,flag_maqSaidaAtiva=0; 
.................... int1 flagBlockI13=0; 
....................  
.................... #INT_RDA2 
.................... void trata_INT_RDA2() 
.................... { 
....................   data_receive=fgetc(PORT2); 
*
000E4:  BRA    00CA
000E6:  MOVFF  01,CC
....................   if(data_receive=='#' && Carriage_Return)  //É o '#'  ---Associar um timeout 
000EA:  MOVF   xCC,W
000EC:  SUBLW  23
000EE:  BNZ   0110
000F0:  BTFSS  xD5.0
000F2:  BRA    0110
....................     { 
....................      //TimeOut=0; 
....................      //count_TimerA=0; 
....................      current_data=0; 
000F4:  CLRF   xD4
....................      Data_Buffer[current_data]=data_receive; 
000F6:  CLRF   03
000F8:  MOVF   xD4,W
000FA:  ADDLW  CD
000FC:  MOVWF  FE9
000FE:  MOVLW  00
00100:  ADDWFC 03,W
00102:  MOVWF  FEA
00104:  MOVFF  CC,FEF
....................      current_data++; 
00108:  INCF   xD4,F
....................      Carriage_Return=0; 
0010A:  BCF    xD5.0
....................      BufferOK=0;  
0010C:  BCF    xD5.1
....................     } 
0010E:  BRA    0156
....................   else   
....................     { 
....................      if(!Carriage_Return) 
00110:  BTFSC  xD5.0
00112:  BRA    0156
....................        { 
....................         if(current_data==6 || data_receive==13)           //  || Timeout     
00114:  MOVF   xD4,W
00116:  SUBLW  06
00118:  BZ    0120
0011A:  MOVF   xCC,W
0011C:  SUBLW  0D
0011E:  BNZ   0142
....................           {Data_Buffer[current_data]=data_receive; 
00120:  CLRF   03
00122:  MOVF   xD4,W
00124:  ADDLW  CD
00126:  MOVWF  FE9
00128:  MOVLW  00
0012A:  ADDWFC 03,W
0012C:  MOVWF  FEA
0012E:  MOVFF  CC,FEF
....................            Carriage_Return=1; 
00132:  BSF    xD5.0
....................            current_data=0; 
00134:  CLRF   xD4
....................            bufferOK=1; 
00136:  BSF    xD5.1
....................            if(data_receive!=13)     //erro 
00138:  MOVF   xCC,W
0013A:  SUBLW  0D
0013C:  BZ    0140
....................               bufferOK=0; 
0013E:  BCF    xD5.1
....................           } 
00140:  BRA    0156
....................         else 
....................           {Data_Buffer[current_data]=data_receive; 
00142:  CLRF   03
00144:  MOVF   xD4,W
00146:  ADDLW  CD
00148:  MOVWF  FE9
0014A:  MOVLW  00
0014C:  ADDWFC 03,W
0014E:  MOVWF  FEA
00150:  MOVFF  CC,FEF
....................            current_data++; 
00154:  INCF   xD4,F
....................           } 
....................        } 
....................     } 
.................... } 
....................  
....................  
....................  
....................  
....................  
00156:  BCF    FA4.5
00158:  GOTO   0074
.................... #INT_RTCC 
.................... void trata_t0()             //Entra aqui a cada 5ms 
.................... { 
.................... count_TimerA++; 
0015C:  INCF   xD6,F
.................... count_TimerB++; 
0015E:  INCF   xD7,F
.................... count_TimerC++; 
00160:  INCF   xD8,F
.................... count_TimerD++; 
00162:  INCF   xD9,F
.................... count_TimerE++; 
00164:  INCF   xDA,F
....................  
....................  
.................... TimerI1on++;    //Timer 5ms 
00166:  INCF   x68,F
00168:  BTFSC  FD8.2
0016A:  INCF   x69,F
.................... TimerI1off++;   //Timer 5ms 
0016C:  INCF   x6A,F
0016E:  BTFSC  FD8.2
00170:  INCF   x6B,F
.................... TimerI2on++;    //Timer 5ms 
00172:  INCF   x6C,F
00174:  BTFSC  FD8.2
00176:  INCF   x6D,F
.................... TimerI2off++;   //Timer 5ms 
00178:  INCF   x6E,F
0017A:  BTFSC  FD8.2
0017C:  INCF   x6F,F
.................... TimerI3on++;    //Timer 5ms 
0017E:  INCF   x70,F
00180:  BTFSC  FD8.2
00182:  INCF   x71,F
.................... TimerI3off++;   //Timer 5ms 
00184:  INCF   x72,F
00186:  BTFSC  FD8.2
00188:  INCF   x73,F
.................... TimerI4on++;    //Timer 5ms 
0018A:  INCF   x74,F
0018C:  BTFSC  FD8.2
0018E:  INCF   x75,F
.................... TimerI4off++;   //Timer 5ms 
00190:  INCF   x76,F
00192:  BTFSC  FD8.2
00194:  INCF   x77,F
.................... TimerI5on++;    //Timer 5ms 
00196:  INCF   x78,F
00198:  BTFSC  FD8.2
0019A:  INCF   x79,F
.................... TimerI5off++;   //Timer 5ms 
0019C:  INCF   x7A,F
0019E:  BTFSC  FD8.2
001A0:  INCF   x7B,F
.................... TimerI6on++;    //Timer 5ms 
001A2:  INCF   x7C,F
001A4:  BTFSC  FD8.2
001A6:  INCF   x7D,F
.................... TimerI6off++;   //Timer 5ms 
001A8:  INCF   x7E,F
001AA:  BTFSC  FD8.2
001AC:  INCF   x7F,F
.................... TimerI7on++;    //Timer 5ms 
001AE:  INCF   x80,F
001B0:  BTFSC  FD8.2
001B2:  INCF   x81,F
.................... TimerI7off++;   //Timer 5ms 
001B4:  INCF   x82,F
001B6:  BTFSC  FD8.2
001B8:  INCF   x83,F
.................... TimerI8on++;    //Timer 5ms 
001BA:  INCF   x84,F
001BC:  BTFSC  FD8.2
001BE:  INCF   x85,F
.................... TimerI8off++;   //Timer 5ms 
001C0:  INCF   x86,F
001C2:  BTFSC  FD8.2
001C4:  INCF   x87,F
....................  
....................  
.................... TimerI9on++;    //Timer 5ms 
001C6:  INCF   x88,F
001C8:  BTFSC  FD8.2
001CA:  INCF   x89,F
.................... TimerI9off++;   //Timer 5ms 
001CC:  INCF   x8A,F
001CE:  BTFSC  FD8.2
001D0:  INCF   x8B,F
.................... TimerI10on++;    //Timer 5ms 
001D2:  INCF   x8C,F
001D4:  BTFSC  FD8.2
001D6:  INCF   x8D,F
.................... TimerI10off++;   //Timer 5ms 
001D8:  INCF   x8E,F
001DA:  BTFSC  FD8.2
001DC:  INCF   x8F,F
.................... TimerI11on++;    //Timer 5ms 
001DE:  INCF   x90,F
001E0:  BTFSC  FD8.2
001E2:  INCF   x91,F
.................... TimerI11off++;   //Timer 5ms 
001E4:  INCF   x92,F
001E6:  BTFSC  FD8.2
001E8:  INCF   x93,F
.................... TimerI12on++;    //Timer 5ms 
001EA:  INCF   x94,F
001EC:  BTFSC  FD8.2
001EE:  INCF   x95,F
.................... TimerI12off++;   //Timer 5ms 
001F0:  INCF   x96,F
001F2:  BTFSC  FD8.2
001F4:  INCF   x97,F
.................... TimerI13on++;    //Timer 5ms 
001F6:  INCF   x98,F
001F8:  BTFSC  FD8.2
001FA:  INCF   x99,F
.................... TimerI13off++;   //Timer 5ms 
001FC:  INCF   x9A,F
001FE:  BTFSC  FD8.2
00200:  INCF   x9B,F
.................... TimerI14on++;    //Timer 5ms 
00202:  INCF   x9C,F
00204:  BTFSC  FD8.2
00206:  INCF   x9D,F
.................... TimerI14off++;   //Timer 5ms 
00208:  INCF   x9E,F
0020A:  BTFSC  FD8.2
0020C:  INCF   x9F,F
.................... TimerI15on++;    //Timer 5ms 
0020E:  INCF   xA0,F
00210:  BTFSC  FD8.2
00212:  INCF   xA1,F
.................... TimerI15off++;   //Timer 5ms 
00214:  INCF   xA2,F
00216:  BTFSC  FD8.2
00218:  INCF   xA3,F
.................... TimerI16on++;    //Timer 5ms 
0021A:  INCF   xA4,F
0021C:  BTFSC  FD8.2
0021E:  INCF   xA5,F
.................... TimerI16off++;   //Timer 5ms 
00220:  INCF   xA6,F
00222:  BTFSC  FD8.2
00224:  INCF   xA7,F
....................  
....................  
....................  
....................  
.................... if(count_timerA<=100) 
00226:  MOVF   xD6,W
00228:  SUBLW  64
0022A:  BNC   0230
....................    SIGNAL_BLINK=1; 
0022C:  BSF    xD5.3
0022E:  BRA    024E
.................... else 
....................   { 
....................    SIGNAL_BLINK=0; 
00230:  BCF    xD5.3
....................    if(count_timerA>=200)   //1 segundo 
00232:  MOVF   xD6,W
00234:  SUBLW  C7
00236:  BC    024E
....................      { 
....................       count_timerA=0; 
00238:  CLRF   xD6
....................       if(TIMER_A<255) 
0023A:  INCFSZ xDB,W
0023C:  BRA    0240
0023E:  BRA    0242
....................          TIMER_A++; 
00240:  INCF   xDB,F
....................      if(TIMER_G12>0) 
00242:  MOVF   xE0,F
00244:  BZ    0248
....................         TIMER_G12--; 
00246:  DECF   xE0,F
....................      if(TIMER_G13>0) 
00248:  MOVF   xE1,F
0024A:  BZ    024E
....................         TIMER_G13--;    
0024C:  DECF   xE1,F
....................      } 
....................   }   
....................       
.................... if(count_timerB>=200)   //1 segundo 
0024E:  MOVF   xD7,W
00250:  SUBLW  C7
00252:  BC    025E
....................      { 
....................       count_timerB=0; 
00254:  CLRF   xD7
....................       if(TIMER_B<255) 
00256:  INCFSZ xDC,W
00258:  BRA    025C
0025A:  BRA    025E
....................          TIMER_B++; 
0025C:  INCF   xDC,F
....................      }     
.................... if(count_timerC>=200)   //1 segundo 
0025E:  MOVF   xD8,W
00260:  SUBLW  C7
00262:  BC    026E
....................      { 
....................       count_timerC=0; 
00264:  CLRF   xD8
....................       if(TIMER_C<255) 
00266:  INCFSZ xDD,W
00268:  BRA    026C
0026A:  BRA    026E
....................          TIMER_C++; 
0026C:  INCF   xDD,F
....................      }   
.................... if(count_timerD>=200)   //1 segundo 
0026E:  MOVF   xD9,W
00270:  SUBLW  C7
00272:  BC    027E
....................      { 
....................       count_timerD=0; 
00274:  CLRF   xD9
....................       if(TIMER_D<255) 
00276:  INCFSZ xDE,W
00278:  BRA    027C
0027A:  BRA    027E
....................          TIMER_D++; 
0027C:  INCF   xDE,F
....................      } 
.................... if(count_timerE>=200)   //1 segundo 
0027E:  MOVF   xDA,W
00280:  SUBLW  C7
00282:  BC    028E
....................      { 
....................       count_timerE=0; 
00284:  CLRF   xDA
....................       if(TIMER_E<255) 
00286:  INCFSZ xDF,W
00288:  BRA    028C
0028A:  BRA    028E
....................          TIMER_E++; 
0028C:  INCF   xDF,F
....................      } 
....................  
....................  
....................  
.................... set_timer0(34286); 
0028E:  MOVLW  85
00290:  MOVWF  FD7
00292:  MOVLW  EE
00294:  MOVWF  FD6
....................  
00296:  BCF    FF2.2
00298:  GOTO   0074
.................... } 
....................  
....................  
....................  
.................... void delay_seg(int8 time) 
.................... { 
....................  int i; 
....................  RESTART_WDT(); 
*
0098E:  CLRWDT
....................  for(i=0;i<time;i++) 
00990:  MOVLB  1
00992:  CLRF   x0E
00994:  MOVF   x0D,W
00996:  SUBWF  x0E,W
00998:  BC    09B0
....................     delay_ms(1000); 
0099A:  MOVLW  04
0099C:  MOVWF  x0F
0099E:  MOVLW  FA
009A0:  MOVWF  x29
009A2:  MOVLB  0
009A4:  RCALL  0964
009A6:  MOVLB  1
009A8:  DECFSZ x0F,F
009AA:  BRA    099E
009AC:  INCF   x0E,F
009AE:  BRA    0994
009B0:  MOVLB  0
009B2:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void ImprimeMSGRS232(int1 msg) //0:Erro, 1:OK 
.................... { 
.................... if(!msg) 
*
00B76:  MOVLB  1
00B78:  MOVF   x22,F
00B7A:  BNZ   0B92
....................   { 
....................    fputc('#',PORT2); //STX 
00B7C:  MOVLW  23
00B7E:  MOVLB  0
00B80:  RCALL  0B6C
....................    fputc('E',PORT2); //ERRO 
00B82:  MOVLW  45
00B84:  RCALL  0B6C
....................    fputc('R',PORT2); // 
00B86:  MOVLW  52
00B88:  RCALL  0B6C
....................    fputc(13,PORT2); 
00B8A:  MOVLW  0D
00B8C:  RCALL  0B6C
....................   } 
00B8E:  BRA    0BA4
00B90:  MOVLB  1
.................... else 
....................   { 
....................    fputc('#',PORT2); //STX 
00B92:  MOVLW  23
00B94:  MOVLB  0
00B96:  RCALL  0B6C
....................    fputc('O',PORT2);  
00B98:  MOVLW  4F
00B9A:  RCALL  0B6C
....................    fputc('K',PORT2); 
00B9C:  MOVLW  4B
00B9E:  RCALL  0B6C
....................    fputc(13,PORT2); 
00BA0:  MOVLW  0D
00BA2:  RCALL  0B6C
....................   } 
00BA4:  RETURN 0
.................... } 
....................  
....................  
.................... void trata_msgAtoI(unsigned int32 i_ee,int8 i_temp,int16 max)   //máx 199 
00BA6:  MOVLB  1
00BA8:  CLRF   x1D
00BAA:  CLRF   x1C
00BAC:  CLRF   x1F
00BAE:  CLRF   x1E
00BB0:  CLRF   x21
00BB2:  CLRF   x20
.................... { 
.................... int16 aux=0; 
.................... int16 MSB=0,LSB=0; 
....................  
.................... if((Data_Buffer[2]>='0' && Data_Buffer[2]<='2') && (Data_Buffer[3]>='0' && Data_Buffer[3]<='9') &&  
....................  
.................... (Data_Buffer[4]>='0' && Data_Buffer[4]<='9') && (Data_Buffer[5]==13))   //são 3 digitos 
00BB4:  MOVLB  0
00BB6:  MOVF   xCF,W
00BB8:  SUBLW  2F
00BBA:  BTFSC  FD8.0
00BBC:  BRA    0CAE
00BBE:  MOVF   xCF,W
00BC0:  SUBLW  32
00BC2:  BTFSS  FD8.0
00BC4:  BRA    0CAE
00BC6:  MOVF   xD0,W
00BC8:  SUBLW  2F
00BCA:  BTFSC  FD8.0
00BCC:  BRA    0CAE
00BCE:  MOVF   xD0,W
00BD0:  SUBLW  39
00BD2:  BTFSS  FD8.0
00BD4:  BRA    0CAE
00BD6:  MOVF   xD1,W
00BD8:  SUBLW  2F
00BDA:  BC    0CAE
00BDC:  MOVF   xD1,W
00BDE:  SUBLW  39
00BE0:  BNC   0CAE
00BE2:  MOVF   xD2,W
00BE4:  SUBLW  0D
00BE6:  BNZ   0CAE
....................   { 
....................    MSB=Data_Buffer[2]-48; 
00BE8:  MOVLW  30
00BEA:  SUBWF  xCF,W
00BEC:  MOVLB  1
00BEE:  MOVWF  x1E
00BF0:  CLRF   x1F
....................    MSB=MSB*100; 
00BF2:  MOVFF  11F,123
00BF6:  MOVFF  11E,122
00BFA:  CLRF   x25
00BFC:  MOVLW  64
00BFE:  MOVWF  x24
00C00:  MOVLB  0
00C02:  RCALL  0AD6
00C04:  MOVFF  02,11F
00C08:  MOVFF  01,11E
....................    LSB=Data_Buffer[3]-48; 
00C0C:  MOVLW  30
00C0E:  SUBWF  xD0,W
00C10:  MOVLB  1
00C12:  MOVWF  x20
00C14:  CLRF   x21
....................    LSB=LSB*10; 
00C16:  MOVFF  121,123
00C1A:  MOVFF  120,122
00C1E:  CLRF   x25
00C20:  MOVLW  0A
00C22:  MOVWF  x24
00C24:  MOVLB  0
00C26:  RCALL  0AD6
00C28:  MOVFF  02,121
00C2C:  MOVFF  01,120
....................    MSB=MSB+LSB; 
00C30:  MOVLB  1
00C32:  MOVF   x20,W
00C34:  ADDWF  x1E,F
00C36:  MOVF   x21,W
00C38:  ADDWFC x1F,F
....................    LSB=Data_Buffer[4]-48; 
00C3A:  MOVLW  30
00C3C:  MOVLB  0
00C3E:  SUBWF  xD1,W
00C40:  MOVLB  1
00C42:  MOVWF  x20
00C44:  CLRF   x21
....................    aux=MSB+LSB; 
00C46:  MOVF   x20,W
00C48:  ADDWF  x1E,W
00C4A:  MOVWF  x1C
00C4C:  MOVF   x21,W
00C4E:  ADDWFC x1F,W
00C50:  MOVWF  x1D
....................    if(aux<=max) 
00C52:  MOVF   x1D,W
00C54:  SUBWF  x1B,W
00C56:  BNC   0CA6
00C58:  BNZ   0C60
00C5A:  MOVF   x1C,W
00C5C:  SUBWF  x1A,W
00C5E:  BNC   0CA6
....................      {Tempos[i_temp]=(int8) aux; 
00C60:  CLRF   03
00C62:  MOVF   x19,W
00C64:  ADDLW  E2
00C66:  MOVWF  FE9
00C68:  MOVLW  00
00C6A:  ADDWFC 03,W
00C6C:  MOVWF  FEA
00C6E:  MOVFF  11C,FEF
....................       write_ext_eeprom(i_ee, Tempos[i_temp]); 
00C72:  CLRF   03
00C74:  MOVF   x19,W
00C76:  ADDLW  E2
00C78:  MOVWF  FE9
00C7A:  MOVLW  00
00C7C:  ADDWFC 03,W
00C7E:  MOVWF  FEA
00C80:  MOVFF  FEF,127
00C84:  MOVFF  118,126
00C88:  MOVFF  117,125
00C8C:  MOVFF  116,124
00C90:  MOVFF  115,123
00C94:  MOVLB  0
00C96:  RCALL  0AF8
....................       ImprimeMSGRS232(1);          //OK  
00C98:  MOVLW  01
00C9A:  MOVLB  1
00C9C:  MOVWF  x22
00C9E:  MOVLB  0
00CA0:  RCALL  0B76
....................      } 
00CA2:  BRA    0CAC
00CA4:  MOVLB  1
....................    else 
....................       ImprimeMSGRS232(0);          //ERRO 
00CA6:  CLRF   x22
00CA8:  MOVLB  0
00CAA:  RCALL  0B76
....................   } 
00CAC:  BRA    0DEA
.................... else 
....................   { 
....................    if((Data_Buffer[2]>='0' && Data_Buffer[2]<='9') && (Data_Buffer[3]>='0' && Data_Buffer[3]<='9') &&  
....................  
.................... (Data_Buffer[4]==13))   //são dois digitos 
00CAE:  MOVF   xCF,W
00CB0:  SUBLW  2F
00CB2:  BC    0D62
00CB4:  MOVF   xCF,W
00CB6:  SUBLW  39
00CB8:  BNC   0D62
00CBA:  MOVF   xD0,W
00CBC:  SUBLW  2F
00CBE:  BC    0D62
00CC0:  MOVF   xD0,W
00CC2:  SUBLW  39
00CC4:  BNC   0D62
00CC6:  MOVF   xD1,W
00CC8:  SUBLW  0D
00CCA:  BNZ   0D62
....................      { 
....................       MSB=Data_Buffer[2]-48; 
00CCC:  MOVLW  30
00CCE:  SUBWF  xCF,W
00CD0:  MOVLB  1
00CD2:  MOVWF  x1E
00CD4:  CLRF   x1F
....................       MSB=MSB*10; 
00CD6:  MOVFF  11F,123
00CDA:  MOVFF  11E,122
00CDE:  CLRF   x25
00CE0:  MOVLW  0A
00CE2:  MOVWF  x24
00CE4:  MOVLB  0
00CE6:  RCALL  0AD6
00CE8:  MOVFF  02,11F
00CEC:  MOVFF  01,11E
....................       LSB=Data_Buffer[3]-48; 
00CF0:  MOVLW  30
00CF2:  SUBWF  xD0,W
00CF4:  MOVLB  1
00CF6:  MOVWF  x20
00CF8:  CLRF   x21
....................       aux=MSB+LSB; 
00CFA:  MOVF   x20,W
00CFC:  ADDWF  x1E,W
00CFE:  MOVWF  x1C
00D00:  MOVF   x21,W
00D02:  ADDWFC x1F,W
00D04:  MOVWF  x1D
....................       if(aux<=max) 
00D06:  MOVF   x1D,W
00D08:  SUBWF  x1B,W
00D0A:  BNC   0D5A
00D0C:  BNZ   0D14
00D0E:  MOVF   x1C,W
00D10:  SUBWF  x1A,W
00D12:  BNC   0D5A
....................         {Tempos[i_temp]=(int8) aux; 
00D14:  CLRF   03
00D16:  MOVF   x19,W
00D18:  ADDLW  E2
00D1A:  MOVWF  FE9
00D1C:  MOVLW  00
00D1E:  ADDWFC 03,W
00D20:  MOVWF  FEA
00D22:  MOVFF  11C,FEF
....................          write_ext_eeprom(i_ee, Tempos[i_temp]); 
00D26:  CLRF   03
00D28:  MOVF   x19,W
00D2A:  ADDLW  E2
00D2C:  MOVWF  FE9
00D2E:  MOVLW  00
00D30:  ADDWFC 03,W
00D32:  MOVWF  FEA
00D34:  MOVFF  FEF,127
00D38:  MOVFF  118,126
00D3C:  MOVFF  117,125
00D40:  MOVFF  116,124
00D44:  MOVFF  115,123
00D48:  MOVLB  0
00D4A:  RCALL  0AF8
....................          ImprimeMSGRS232(1);          //OK  
00D4C:  MOVLW  01
00D4E:  MOVLB  1
00D50:  MOVWF  x22
00D52:  MOVLB  0
00D54:  RCALL  0B76
....................         } 
00D56:  BRA    0D60
00D58:  MOVLB  1
....................       else 
....................         ImprimeMSGRS232(0);          //ERRO 
00D5A:  CLRF   x22
00D5C:  MOVLB  0
00D5E:  RCALL  0B76
....................      } 
00D60:  BRA    0DEA
....................    else 
....................      { 
....................       if((Data_Buffer[2]>='0' && Data_Buffer[2]<='9') && (Data_Buffer[3]==13))   //é 1 dígito 
00D62:  MOVF   xCF,W
00D64:  SUBLW  2F
00D66:  BC    0DE2
00D68:  MOVF   xCF,W
00D6A:  SUBLW  39
00D6C:  BNC   0DE2
00D6E:  MOVF   xD0,W
00D70:  SUBLW  0D
00D72:  BNZ   0DE2
....................         { 
....................          LSB=Data_Buffer[2]-48; 
00D74:  MOVLW  30
00D76:  SUBWF  xCF,W
00D78:  MOVLB  1
00D7A:  MOVWF  x20
00D7C:  CLRF   x21
....................          aux=LSB; 
00D7E:  MOVFF  121,11D
00D82:  MOVFF  120,11C
....................          if(aux<=LSB) 
00D86:  MOVF   x1D,W
00D88:  SUBWF  x21,W
00D8A:  BNC   0DDA
00D8C:  BNZ   0D94
00D8E:  MOVF   x1C,W
00D90:  SUBWF  x20,W
00D92:  BNC   0DDA
....................            {Tempos[i_temp]=(int8) aux; 
00D94:  CLRF   03
00D96:  MOVF   x19,W
00D98:  ADDLW  E2
00D9A:  MOVWF  FE9
00D9C:  MOVLW  00
00D9E:  ADDWFC 03,W
00DA0:  MOVWF  FEA
00DA2:  MOVFF  11C,FEF
....................             write_ext_eeprom(i_ee, Tempos[i_temp]); 
00DA6:  CLRF   03
00DA8:  MOVF   x19,W
00DAA:  ADDLW  E2
00DAC:  MOVWF  FE9
00DAE:  MOVLW  00
00DB0:  ADDWFC 03,W
00DB2:  MOVWF  FEA
00DB4:  MOVFF  FEF,127
00DB8:  MOVFF  118,126
00DBC:  MOVFF  117,125
00DC0:  MOVFF  116,124
00DC4:  MOVFF  115,123
00DC8:  MOVLB  0
00DCA:  RCALL  0AF8
....................             ImprimeMSGRS232(1);          //OK                    
00DCC:  MOVLW  01
00DCE:  MOVLB  1
00DD0:  MOVWF  x22
00DD2:  MOVLB  0
00DD4:  RCALL  0B76
....................            } 
00DD6:  BRA    0DE0
00DD8:  MOVLB  1
....................          else 
....................            ImprimeMSGRS232(0); 
00DDA:  CLRF   x22
00DDC:  MOVLB  0
00DDE:  RCALL  0B76
....................         } 
00DE0:  BRA    0DEA
....................       else 
....................         ImprimeMSGRS232(0); 
00DE2:  MOVLB  1
00DE4:  CLRF   x22
00DE6:  MOVLB  0
00DE8:  RCALL  0B76
....................       } 
....................    } 
00DEA:  RETURN 0
.................... } 
....................  
....................  
.................... void trata_buffer(){ 
*
01032:  MOVLB  1
01034:  CLRF   x0D
.................... unsigned int8 data=0; 
.................... BYTE year, mth, date, dow, hr, min, sec; 
....................  
....................  
....................  
.................... delay_ms(10); 
01036:  MOVLW  0A
01038:  MOVWF  x29
0103A:  MOVLB  0
0103C:  RCALL  0964
....................  
....................  
.................... switch(Data_Buffer[1]){ 
0103E:  MOVLW  23
01040:  SUBWF  xCE,W
01042:  ADDLW  BD
01044:  BTFSC  FD8.0
01046:  GOTO   1C34
0104A:  ADDLW  43
0104C:  GOTO   1C38
....................       case '#':if(Data_Buffer[2]=='#' && Data_Buffer[3]==13) 
01050:  MOVF   xCF,W
01052:  SUBLW  23
01054:  BNZ   1082
01056:  MOVF   xD0,W
01058:  SUBLW  0D
0105A:  BNZ   1082
....................                  { 
....................                   if(!LinhaComando) 
0105C:  BTFSC  xD5.2
0105E:  BRA    1072
....................                     {LinhaComando=1; 
01060:  BSF    xD5.2
....................                      fprintf(PORT2,"Modo Linha de Comandos Activado\n\r"); 
01062:  MOVLW  9C
01064:  MOVWF  FF6
01066:  MOVLW  02
01068:  MOVWF  FF7
0106A:  MOVLW  00
0106C:  MOVWF  FF8
0106E:  RCALL  09B4
....................                     } 
01070:  BRA    1082
....................                   else 
....................                     { 
....................                      LinhaComando=0; 
01072:  BCF    xD5.2
....................                      fprintf(PORT2,"Modo Linha de Comandos Desactivado\n\r"); 
01074:  MOVLW  BE
01076:  MOVWF  FF6
01078:  MOVLW  02
0107A:  MOVWF  FF7
0107C:  MOVLW  00
0107E:  MOVWF  FF8
01080:  RCALL  09B4
....................                     }             
....................                  } 
....................                break; 
01082:  GOTO   1C34
....................       case 'A':if(LinhaComando) 
01086:  BTFSS  xD5.2
01088:  BRA    10A0
....................                   trata_msgAtoI(0,0,150);  //Tempo A [seg] 
0108A:  MOVLB  1
0108C:  CLRF   x18
0108E:  CLRF   x17
01090:  CLRF   x16
01092:  CLRF   x15
01094:  CLRF   x19
01096:  CLRF   x1B
01098:  MOVLW  96
0109A:  MOVWF  x1A
0109C:  MOVLB  0
0109E:  RCALL  0BA6
....................                break; 
010A0:  GOTO   1C34
....................       case 'B':if(LinhaComando) 
010A4:  BTFSS  xD5.2
010A6:  BRA    10C0
....................                   trata_msgAtoI(1,1,250);  //Tempo B [seg] 
010A8:  MOVLB  1
010AA:  CLRF   x18
010AC:  CLRF   x17
010AE:  CLRF   x16
010B0:  MOVLW  01
010B2:  MOVWF  x15
010B4:  MOVWF  x19
010B6:  CLRF   x1B
010B8:  MOVLW  FA
010BA:  MOVWF  x1A
010BC:  MOVLB  0
010BE:  RCALL  0BA6
....................                break; 
010C0:  GOTO   1C34
....................       case 'C':if(LinhaComando) 
010C4:  BTFSS  xD5.2
010C6:  BRA    10E0
....................                   trata_msgAtoI(2,2,25);   //Tempo C [seg] 
010C8:  MOVLB  1
010CA:  CLRF   x18
010CC:  CLRF   x17
010CE:  CLRF   x16
010D0:  MOVLW  02
010D2:  MOVWF  x15
010D4:  MOVWF  x19
010D6:  CLRF   x1B
010D8:  MOVLW  19
010DA:  MOVWF  x1A
010DC:  MOVLB  0
010DE:  RCALL  0BA6
....................                break; 
010E0:  GOTO   1C34
....................       case 'D':if(LinhaComando) 
010E4:  BTFSS  xD5.2
010E6:  BRA    1100
....................                   trata_msgAtoI(3,3,150);  //Tempo D [seg] 
010E8:  MOVLB  1
010EA:  CLRF   x18
010EC:  CLRF   x17
010EE:  CLRF   x16
010F0:  MOVLW  03
010F2:  MOVWF  x15
010F4:  MOVWF  x19
010F6:  CLRF   x1B
010F8:  MOVLW  96
010FA:  MOVWF  x1A
010FC:  MOVLB  0
010FE:  RCALL  0BA6
....................                break; 
01100:  GOTO   1C34
....................       case 'E':if(LinhaComando) 
01104:  BTFSS  xD5.2
01106:  BRA    1120
....................                   trata_msgAtoI(4,4,250);  //Tempo E [seg] 
01108:  MOVLB  1
0110A:  CLRF   x18
0110C:  CLRF   x17
0110E:  CLRF   x16
01110:  MOVLW  04
01112:  MOVWF  x15
01114:  MOVWF  x19
01116:  CLRF   x1B
01118:  MOVLW  FA
0111A:  MOVWF  x1A
0111C:  MOVLB  0
0111E:  RCALL  0BA6
....................                break; 
01120:  GOTO   1C34
....................       case 'F':if(LinhaComando) 
01124:  BTFSS  xD5.2
01126:  BRA    1140
....................                   trata_msgAtoI(5,5,25);   //Tempo F [seg] 
01128:  MOVLB  1
0112A:  CLRF   x18
0112C:  CLRF   x17
0112E:  CLRF   x16
01130:  MOVLW  05
01132:  MOVWF  x15
01134:  MOVWF  x19
01136:  CLRF   x1B
01138:  MOVLW  19
0113A:  MOVWF  x1A
0113C:  MOVLB  0
0113E:  RCALL  0BA6
....................                break; 
01140:  GOTO   1C34
....................       case 'G':if(LinhaComando) 
01144:  BTFSS  xD5.2
01146:  BRA    1160
....................                   trata_msgAtoI(6,6,150);  //Tempo G [seg] 
01148:  MOVLB  1
0114A:  CLRF   x18
0114C:  CLRF   x17
0114E:  CLRF   x16
01150:  MOVLW  06
01152:  MOVWF  x15
01154:  MOVWF  x19
01156:  CLRF   x1B
01158:  MOVLW  96
0115A:  MOVWF  x1A
0115C:  MOVLB  0
0115E:  RCALL  0BA6
....................                break;          
01160:  GOTO   1C34
....................       case 'H':if(LinhaComando) 
01164:  BTFSS  xD5.2
01166:  BRA    1180
....................                   trata_msgAtoI(7,7,250);  //Tempo H [seg] 
01168:  MOVLB  1
0116A:  CLRF   x18
0116C:  CLRF   x17
0116E:  CLRF   x16
01170:  MOVLW  07
01172:  MOVWF  x15
01174:  MOVWF  x19
01176:  CLRF   x1B
01178:  MOVLW  FA
0117A:  MOVWF  x1A
0117C:  MOVLB  0
0117E:  RCALL  0BA6
....................                break;             
01180:  GOTO   1C34
....................       case 'I':if(LinhaComando) 
01184:  BTFSS  xD5.2
01186:  BRA    11A0
....................                   trata_msgAtoI(8,8,25);   //Tempo I [seg] 
01188:  MOVLB  1
0118A:  CLRF   x18
0118C:  CLRF   x17
0118E:  CLRF   x16
01190:  MOVLW  08
01192:  MOVWF  x15
01194:  MOVWF  x19
01196:  CLRF   x1B
01198:  MOVLW  19
0119A:  MOVWF  x1A
0119C:  MOVLB  0
0119E:  RCALL  0BA6
....................                break;            
011A0:  GOTO   1C34
....................       case 'J':if(LinhaComando) 
011A4:  BTFSS  xD5.2
011A6:  BRA    11C0
....................                   trata_msgAtoI(9,9,120);   //Tempo J [seg] 
011A8:  MOVLB  1
011AA:  CLRF   x18
011AC:  CLRF   x17
011AE:  CLRF   x16
011B0:  MOVLW  09
011B2:  MOVWF  x15
011B4:  MOVWF  x19
011B6:  CLRF   x1B
011B8:  MOVLW  78
011BA:  MOVWF  x1A
011BC:  MOVLB  0
011BE:  RCALL  0BA6
....................                break;         
011C0:  GOTO   1C34
....................       case 'K':if(LinhaComando) 
011C4:  BTFSS  xD5.2
011C6:  BRA    11E0
....................                   trata_msgAtoI(10,10,120);   //Tempo K [seg] 
011C8:  MOVLB  1
011CA:  CLRF   x18
011CC:  CLRF   x17
011CE:  CLRF   x16
011D0:  MOVLW  0A
011D2:  MOVWF  x15
011D4:  MOVWF  x19
011D6:  CLRF   x1B
011D8:  MOVLW  78
011DA:  MOVWF  x1A
011DC:  MOVLB  0
011DE:  RCALL  0BA6
....................                break;         
011E0:  GOTO   1C34
....................       case 'L':if(LinhaComando) 
011E4:  BTFSS  xD5.2
011E6:  BRA    1200
....................                   trata_msgAtoI(11,11,120);   //Tempo L [seg] 
011E8:  MOVLB  1
011EA:  CLRF   x18
011EC:  CLRF   x17
011EE:  CLRF   x16
011F0:  MOVLW  0B
011F2:  MOVWF  x15
011F4:  MOVWF  x19
011F6:  CLRF   x1B
011F8:  MOVLW  78
011FA:  MOVWF  x1A
011FC:  MOVLB  0
011FE:  RCALL  0BA6
....................                break;     
01200:  GOTO   1C34
....................       case 'M':if(LinhaComando) 
01204:  BTFSS  xD5.2
01206:  BRA    1220
....................                   trata_msgAtoI(12,12,120);   //Tempo M [seg] 
01208:  MOVLB  1
0120A:  CLRF   x18
0120C:  CLRF   x17
0120E:  CLRF   x16
01210:  MOVLW  0C
01212:  MOVWF  x15
01214:  MOVWF  x19
01216:  CLRF   x1B
01218:  MOVLW  78
0121A:  MOVWF  x1A
0121C:  MOVLB  0
0121E:  RCALL  0BA6
....................                break;          
01220:  GOTO   1C34
....................       case 'N':if(LinhaComando) 
01224:  BTFSS  xD5.2
01226:  BRA    1240
....................                   trata_msgAtoI(13,13,120);   //Tempo N [seg] 
01228:  MOVLB  1
0122A:  CLRF   x18
0122C:  CLRF   x17
0122E:  CLRF   x16
01230:  MOVLW  0D
01232:  MOVWF  x15
01234:  MOVWF  x19
01236:  CLRF   x1B
01238:  MOVLW  78
0123A:  MOVWF  x1A
0123C:  MOVLB  0
0123E:  RCALL  0BA6
....................                break;         
01240:  GOTO   1C34
....................       case 'O':if(LinhaComando) 
01244:  BTFSS  xD5.2
01246:  BRA    1260
....................                   trata_msgAtoI(14,14,120);   //Tempo O [seg] 
01248:  MOVLB  1
0124A:  CLRF   x18
0124C:  CLRF   x17
0124E:  CLRF   x16
01250:  MOVLW  0E
01252:  MOVWF  x15
01254:  MOVWF  x19
01256:  CLRF   x1B
01258:  MOVLW  78
0125A:  MOVWF  x1A
0125C:  MOVLB  0
0125E:  RCALL  0BA6
....................                break;         
01260:  GOTO   1C34
....................       case 'P':if(LinhaComando) 
01264:  BTFSS  xD5.2
01266:  BRA    127E
....................                   trata_msgAtoI(15,15,255);   //Tempo P [seg] 
01268:  MOVLB  1
0126A:  CLRF   x18
0126C:  CLRF   x17
0126E:  CLRF   x16
01270:  MOVLW  0F
01272:  MOVWF  x15
01274:  MOVWF  x19
01276:  CLRF   x1B
01278:  SETF   x1A
0127A:  MOVLB  0
0127C:  RCALL  0BA6
....................                break;             
0127E:  GOTO   1C34
....................       case 'Q': 
....................                break;                        
01282:  GOTO   1C34
....................       case 'R':if(LinhaComando) 
01286:  BTFSS  xD5.2
01288:  BRA    128C
....................                   reset_cpu();  
0128A:  RESET
....................                break;      
0128C:  GOTO   1C34
....................       case 'S':if(LinhaComando) 
01290:  BTFSS  xD5.2
01292:  BRA    18A8
....................                  if(Data_Buffer[2]=='W' && Data_Buffer[3]==13)             //Mostra dados contidos na EEPROM 
01294:  MOVF   xCF,W
01296:  SUBLW  57
01298:  BTFSS  FD8.2
0129A:  BRA    18A8
0129C:  MOVF   xD0,W
0129E:  SUBLW  0D
012A0:  BTFSS  FD8.2
012A2:  BRA    18A8
....................                     {                                                                                          
....................                      data = read_ext_eeprom(0); 
012A4:  MOVLB  1
012A6:  CLRF   x18
012A8:  CLRF   x17
012AA:  CLRF   x16
012AC:  CLRF   x15
012AE:  MOVLB  0
012B0:  CALL   0A12
012B4:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Verde mínimo G1[seg]=%u\n\r",data); 
012B8:  MOVLW  E4
012BA:  MOVWF  FF6
012BC:  MOVLW  02
012BE:  MOVWF  FF7
012C0:  MOVLW  00
012C2:  MOVWF  FF8
012C4:  MOVLW  1B
012C6:  MOVLB  1
012C8:  MOVWF  x15
012CA:  MOVLB  0
012CC:  RCALL  0DEC
012CE:  MOVFF  10D,115
012D2:  MOVLW  1B
012D4:  MOVLB  1
012D6:  MOVWF  x16
012D8:  MOVLB  0
012DA:  RCALL  0E4C
012DC:  MOVLW  0A
012DE:  CLRWDT
012E0:  BTFSS  FA4.4
012E2:  BRA    12DE
012E4:  MOVWF  F6D
012E6:  MOVLW  0D
012E8:  CLRWDT
012EA:  BTFSS  FA4.4
012EC:  BRA    12E8
012EE:  MOVWF  F6D
....................                      delay_ms(2); 
012F0:  MOVLW  02
012F2:  MOVLB  1
012F4:  MOVWF  x29
012F6:  MOVLB  0
012F8:  CALL   0964
....................                      data = read_ext_eeprom(1); 
012FC:  MOVLB  1
012FE:  CLRF   x18
01300:  CLRF   x17
01302:  CLRF   x16
01304:  MOVLW  01
01306:  MOVWF  x15
01308:  MOVLB  0
0130A:  CALL   0A12
0130E:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Verde máximo G1[seg]=%u\n\r",data); 
01312:  MOVLW  04
01314:  MOVWF  FF6
01316:  MOVLW  03
01318:  MOVWF  FF7
0131A:  MOVLW  00
0131C:  MOVWF  FF8
0131E:  MOVLW  1B
01320:  MOVLB  1
01322:  MOVWF  x15
01324:  MOVLB  0
01326:  RCALL  0DEC
01328:  MOVFF  10D,115
0132C:  MOVLW  1B
0132E:  MOVLB  1
01330:  MOVWF  x16
01332:  MOVLB  0
01334:  RCALL  0E4C
01336:  MOVLW  0A
01338:  CLRWDT
0133A:  BTFSS  FA4.4
0133C:  BRA    1338
0133E:  MOVWF  F6D
01340:  MOVLW  0D
01342:  CLRWDT
01344:  BTFSS  FA4.4
01346:  BRA    1342
01348:  MOVWF  F6D
....................                      delay_ms(2); 
0134A:  MOVLW  02
0134C:  MOVLB  1
0134E:  MOVWF  x29
01350:  MOVLB  0
01352:  CALL   0964
....................                      data = read_ext_eeprom(2); 
01356:  MOVLB  1
01358:  CLRF   x18
0135A:  CLRF   x17
0135C:  CLRF   x16
0135E:  MOVLW  02
01360:  MOVWF  x15
01362:  MOVLB  0
01364:  CALL   0A12
01368:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Incremento G1[seg]=%u\n\r",data); 
0136C:  MOVLW  24
0136E:  MOVWF  FF6
01370:  MOVLW  03
01372:  MOVWF  FF7
01374:  MOVLW  00
01376:  MOVWF  FF8
01378:  MOVLW  19
0137A:  MOVLB  1
0137C:  MOVWF  x15
0137E:  MOVLB  0
01380:  RCALL  0DEC
01382:  MOVFF  10D,115
01386:  MOVLW  1B
01388:  MOVLB  1
0138A:  MOVWF  x16
0138C:  MOVLB  0
0138E:  RCALL  0E4C
01390:  MOVLW  0A
01392:  CLRWDT
01394:  BTFSS  FA4.4
01396:  BRA    1392
01398:  MOVWF  F6D
0139A:  MOVLW  0D
0139C:  CLRWDT
0139E:  BTFSS  FA4.4
013A0:  BRA    139C
013A2:  MOVWF  F6D
....................                      delay_ms(2); 
013A4:  MOVLW  02
013A6:  MOVLB  1
013A8:  MOVWF  x29
013AA:  MOVLB  0
013AC:  CALL   0964
....................                      data = read_ext_eeprom(3); 
013B0:  MOVLB  1
013B2:  CLRF   x18
013B4:  CLRF   x17
013B6:  CLRF   x16
013B8:  MOVLW  03
013BA:  MOVWF  x15
013BC:  MOVLB  0
013BE:  CALL   0A12
013C2:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Verde mínimo G2[seg]=%u\n\r",data); 
013C6:  MOVLW  42
013C8:  MOVWF  FF6
013CA:  MOVLW  03
013CC:  MOVWF  FF7
013CE:  MOVLW  00
013D0:  MOVWF  FF8
013D2:  MOVLW  1B
013D4:  MOVLB  1
013D6:  MOVWF  x15
013D8:  MOVLB  0
013DA:  RCALL  0DEC
013DC:  MOVFF  10D,115
013E0:  MOVLW  1B
013E2:  MOVLB  1
013E4:  MOVWF  x16
013E6:  MOVLB  0
013E8:  RCALL  0E4C
013EA:  MOVLW  0A
013EC:  CLRWDT
013EE:  BTFSS  FA4.4
013F0:  BRA    13EC
013F2:  MOVWF  F6D
013F4:  MOVLW  0D
013F6:  CLRWDT
013F8:  BTFSS  FA4.4
013FA:  BRA    13F6
013FC:  MOVWF  F6D
....................                      delay_ms(2); 
013FE:  MOVLW  02
01400:  MOVLB  1
01402:  MOVWF  x29
01404:  MOVLB  0
01406:  CALL   0964
....................                      data = read_ext_eeprom(4); 
0140A:  MOVLB  1
0140C:  CLRF   x18
0140E:  CLRF   x17
01410:  CLRF   x16
01412:  MOVLW  04
01414:  MOVWF  x15
01416:  MOVLB  0
01418:  CALL   0A12
0141C:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Verde máximo G2 [seg]=%u\n\r",data); 
01420:  MOVLW  62
01422:  MOVWF  FF6
01424:  MOVLW  03
01426:  MOVWF  FF7
01428:  MOVLW  00
0142A:  MOVWF  FF8
0142C:  MOVLW  1C
0142E:  MOVLB  1
01430:  MOVWF  x15
01432:  MOVLB  0
01434:  RCALL  0DEC
01436:  MOVFF  10D,115
0143A:  MOVLW  1B
0143C:  MOVLB  1
0143E:  MOVWF  x16
01440:  MOVLB  0
01442:  RCALL  0E4C
01444:  MOVLW  0A
01446:  CLRWDT
01448:  BTFSS  FA4.4
0144A:  BRA    1446
0144C:  MOVWF  F6D
0144E:  MOVLW  0D
01450:  CLRWDT
01452:  BTFSS  FA4.4
01454:  BRA    1450
01456:  MOVWF  F6D
....................                      delay_ms(2); 
01458:  MOVLW  02
0145A:  MOVLB  1
0145C:  MOVWF  x29
0145E:  MOVLB  0
01460:  CALL   0964
....................                      data = read_ext_eeprom(5); 
01464:  MOVLB  1
01466:  CLRF   x18
01468:  CLRF   x17
0146A:  CLRF   x16
0146C:  MOVLW  05
0146E:  MOVWF  x15
01470:  MOVLB  0
01472:  CALL   0A12
01476:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Incremento G2 [seg]=%u\n\r",data); 
0147A:  MOVLW  84
0147C:  MOVWF  FF6
0147E:  MOVLW  03
01480:  MOVWF  FF7
01482:  MOVLW  00
01484:  MOVWF  FF8
01486:  MOVLW  1A
01488:  MOVLB  1
0148A:  MOVWF  x15
0148C:  MOVLB  0
0148E:  RCALL  0DEC
01490:  MOVFF  10D,115
01494:  MOVLW  1B
01496:  MOVLB  1
01498:  MOVWF  x16
0149A:  MOVLB  0
0149C:  RCALL  0E4C
0149E:  MOVLW  0A
014A0:  CLRWDT
014A2:  BTFSS  FA4.4
014A4:  BRA    14A0
014A6:  MOVWF  F6D
014A8:  MOVLW  0D
014AA:  CLRWDT
014AC:  BTFSS  FA4.4
014AE:  BRA    14AA
014B0:  MOVWF  F6D
....................                      delay_ms(2); 
014B2:  MOVLW  02
014B4:  MOVLB  1
014B6:  MOVWF  x29
014B8:  MOVLB  0
014BA:  CALL   0964
....................                      data = read_ext_eeprom(6); 
014BE:  MOVLB  1
014C0:  CLRF   x18
014C2:  CLRF   x17
014C4:  CLRF   x16
014C6:  MOVLW  06
014C8:  MOVWF  x15
014CA:  MOVLB  0
014CC:  CALL   0A12
014D0:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Verde mínimo G3 [seg]=%u\n\r",data); 
014D4:  MOVLW  A4
014D6:  MOVWF  FF6
014D8:  MOVLW  03
014DA:  MOVWF  FF7
014DC:  MOVLW  00
014DE:  MOVWF  FF8
014E0:  MOVLW  1C
014E2:  MOVLB  1
014E4:  MOVWF  x15
014E6:  MOVLB  0
014E8:  RCALL  0DEC
014EA:  MOVFF  10D,115
014EE:  MOVLW  1B
014F0:  MOVLB  1
014F2:  MOVWF  x16
014F4:  MOVLB  0
014F6:  RCALL  0E4C
014F8:  MOVLW  0A
014FA:  CLRWDT
014FC:  BTFSS  FA4.4
014FE:  BRA    14FA
01500:  MOVWF  F6D
01502:  MOVLW  0D
01504:  CLRWDT
01506:  BTFSS  FA4.4
01508:  BRA    1504
0150A:  MOVWF  F6D
....................                      delay_ms(2); 
0150C:  MOVLW  02
0150E:  MOVLB  1
01510:  MOVWF  x29
01512:  MOVLB  0
01514:  CALL   0964
....................                      data = read_ext_eeprom(7); 
01518:  MOVLB  1
0151A:  CLRF   x18
0151C:  CLRF   x17
0151E:  CLRF   x16
01520:  MOVLW  07
01522:  MOVWF  x15
01524:  MOVLB  0
01526:  CALL   0A12
0152A:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Verde máximo G3 [seg]=%u\n\r",data); 
0152E:  MOVLW  C6
01530:  MOVWF  FF6
01532:  MOVLW  03
01534:  MOVWF  FF7
01536:  MOVLW  00
01538:  MOVWF  FF8
0153A:  MOVLW  1C
0153C:  MOVLB  1
0153E:  MOVWF  x15
01540:  MOVLB  0
01542:  RCALL  0DEC
01544:  MOVFF  10D,115
01548:  MOVLW  1B
0154A:  MOVLB  1
0154C:  MOVWF  x16
0154E:  MOVLB  0
01550:  RCALL  0E4C
01552:  MOVLW  0A
01554:  CLRWDT
01556:  BTFSS  FA4.4
01558:  BRA    1554
0155A:  MOVWF  F6D
0155C:  MOVLW  0D
0155E:  CLRWDT
01560:  BTFSS  FA4.4
01562:  BRA    155E
01564:  MOVWF  F6D
....................                      delay_ms(2); 
01566:  MOVLW  02
01568:  MOVLB  1
0156A:  MOVWF  x29
0156C:  MOVLB  0
0156E:  CALL   0964
....................                      data = read_ext_eeprom(8); 
01572:  MOVLB  1
01574:  CLRF   x18
01576:  CLRF   x17
01578:  CLRF   x16
0157A:  MOVLW  08
0157C:  MOVWF  x15
0157E:  MOVLB  0
01580:  CALL   0A12
01584:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Incremento G3 [seg]=%u\n\r",data); 
01588:  MOVLW  E8
0158A:  MOVWF  FF6
0158C:  MOVLW  03
0158E:  MOVWF  FF7
01590:  MOVLW  00
01592:  MOVWF  FF8
01594:  MOVLW  1A
01596:  MOVLB  1
01598:  MOVWF  x15
0159A:  MOVLB  0
0159C:  RCALL  0DEC
0159E:  MOVFF  10D,115
015A2:  MOVLW  1B
015A4:  MOVLB  1
015A6:  MOVWF  x16
015A8:  MOVLB  0
015AA:  RCALL  0E4C
015AC:  MOVLW  0A
015AE:  CLRWDT
015B0:  BTFSS  FA4.4
015B2:  BRA    15AE
015B4:  MOVWF  F6D
015B6:  MOVLW  0D
015B8:  CLRWDT
015BA:  BTFSS  FA4.4
015BC:  BRA    15B8
015BE:  MOVWF  F6D
....................                      delay_ms(2); 
015C0:  MOVLW  02
015C2:  MOVLB  1
015C4:  MOVWF  x29
015C6:  MOVLB  0
015C8:  CALL   0964
....................                      data = read_ext_eeprom(9); 
015CC:  MOVLB  1
015CE:  CLRF   x18
015D0:  CLRF   x17
015D2:  CLRF   x16
015D4:  MOVLW  09
015D6:  MOVWF  x15
015D8:  MOVLB  0
015DA:  CALL   0A12
015DE:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Percurso G1 -> G2 [seg]=%u\n\r",data); 
015E2:  MOVLW  08
015E4:  MOVWF  FF6
015E6:  MOVLW  04
015E8:  MOVWF  FF7
015EA:  MOVLW  00
015EC:  MOVWF  FF8
015EE:  MOVLW  1E
015F0:  MOVLB  1
015F2:  MOVWF  x15
015F4:  MOVLB  0
015F6:  CALL   0DEC
015FA:  MOVFF  10D,115
015FE:  MOVLW  1B
01600:  MOVLB  1
01602:  MOVWF  x16
01604:  MOVLB  0
01606:  RCALL  0E4C
01608:  MOVLW  0A
0160A:  CLRWDT
0160C:  BTFSS  FA4.4
0160E:  BRA    160A
01610:  MOVWF  F6D
01612:  MOVLW  0D
01614:  CLRWDT
01616:  BTFSS  FA4.4
01618:  BRA    1614
0161A:  MOVWF  F6D
....................                      delay_ms(2); 
0161C:  MOVLW  02
0161E:  MOVLB  1
01620:  MOVWF  x29
01622:  MOVLB  0
01624:  CALL   0964
....................                      data = read_ext_eeprom(10); 
01628:  MOVLB  1
0162A:  CLRF   x18
0162C:  CLRF   x17
0162E:  CLRF   x16
01630:  MOVLW  0A
01632:  MOVWF  x15
01634:  MOVLB  0
01636:  CALL   0A12
0163A:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Percurso G2 -> G1 [seg]=%u\n\r",data); 
0163E:  MOVLW  2C
01640:  MOVWF  FF6
01642:  MOVLW  04
01644:  MOVWF  FF7
01646:  MOVLW  00
01648:  MOVWF  FF8
0164A:  MOVLW  1E
0164C:  MOVLB  1
0164E:  MOVWF  x15
01650:  MOVLB  0
01652:  CALL   0DEC
01656:  MOVFF  10D,115
0165A:  MOVLW  1B
0165C:  MOVLB  1
0165E:  MOVWF  x16
01660:  MOVLB  0
01662:  CALL   0E4C
01666:  MOVLW  0A
01668:  CLRWDT
0166A:  BTFSS  FA4.4
0166C:  BRA    1668
0166E:  MOVWF  F6D
01670:  MOVLW  0D
01672:  CLRWDT
01674:  BTFSS  FA4.4
01676:  BRA    1672
01678:  MOVWF  F6D
....................                      delay_ms(2); 
0167A:  MOVLW  02
0167C:  MOVLB  1
0167E:  MOVWF  x29
01680:  MOVLB  0
01682:  CALL   0964
....................                      data = read_ext_eeprom(11); 
01686:  MOVLB  1
01688:  CLRF   x18
0168A:  CLRF   x17
0168C:  CLRF   x16
0168E:  MOVLW  0B
01690:  MOVWF  x15
01692:  MOVLB  0
01694:  CALL   0A12
01698:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Percurso G1 -> G3 [seg]=%u\n\r",data); 
0169C:  MOVLW  50
0169E:  MOVWF  FF6
016A0:  MOVLW  04
016A2:  MOVWF  FF7
016A4:  MOVLW  00
016A6:  MOVWF  FF8
016A8:  MOVLW  1E
016AA:  MOVLB  1
016AC:  MOVWF  x15
016AE:  MOVLB  0
016B0:  CALL   0DEC
016B4:  MOVFF  10D,115
016B8:  MOVLW  1B
016BA:  MOVLB  1
016BC:  MOVWF  x16
016BE:  MOVLB  0
016C0:  CALL   0E4C
016C4:  MOVLW  0A
016C6:  CLRWDT
016C8:  BTFSS  FA4.4
016CA:  BRA    16C6
016CC:  MOVWF  F6D
016CE:  MOVLW  0D
016D0:  CLRWDT
016D2:  BTFSS  FA4.4
016D4:  BRA    16D0
016D6:  MOVWF  F6D
....................                      delay_ms(2); 
016D8:  MOVLW  02
016DA:  MOVLB  1
016DC:  MOVWF  x29
016DE:  MOVLB  0
016E0:  CALL   0964
....................                      data = read_ext_eeprom(12); 
016E4:  MOVLB  1
016E6:  CLRF   x18
016E8:  CLRF   x17
016EA:  CLRF   x16
016EC:  MOVLW  0C
016EE:  MOVWF  x15
016F0:  MOVLB  0
016F2:  CALL   0A12
016F6:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Percurso G3 -> G1 [seg]=%u\n\r",data); 
016FA:  MOVLW  74
016FC:  MOVWF  FF6
016FE:  MOVLW  04
01700:  MOVWF  FF7
01702:  MOVLW  00
01704:  MOVWF  FF8
01706:  MOVLW  1E
01708:  MOVLB  1
0170A:  MOVWF  x15
0170C:  MOVLB  0
0170E:  CALL   0DEC
01712:  MOVFF  10D,115
01716:  MOVLW  1B
01718:  MOVLB  1
0171A:  MOVWF  x16
0171C:  MOVLB  0
0171E:  CALL   0E4C
01722:  MOVLW  0A
01724:  CLRWDT
01726:  BTFSS  FA4.4
01728:  BRA    1724
0172A:  MOVWF  F6D
0172C:  MOVLW  0D
0172E:  CLRWDT
01730:  BTFSS  FA4.4
01732:  BRA    172E
01734:  MOVWF  F6D
....................                      delay_ms(2); 
01736:  MOVLW  02
01738:  MOVLB  1
0173A:  MOVWF  x29
0173C:  MOVLB  0
0173E:  CALL   0964
....................                      data = read_ext_eeprom(13); 
01742:  MOVLB  1
01744:  CLRF   x18
01746:  CLRF   x17
01748:  CLRF   x16
0174A:  MOVLW  0D
0174C:  MOVWF  x15
0174E:  MOVLB  0
01750:  CALL   0A12
01754:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Percurso G2 -> G3 [seg]=%u\n\r",data); 
01758:  MOVLW  98
0175A:  MOVWF  FF6
0175C:  MOVLW  04
0175E:  MOVWF  FF7
01760:  MOVLW  00
01762:  MOVWF  FF8
01764:  MOVLW  1E
01766:  MOVLB  1
01768:  MOVWF  x15
0176A:  MOVLB  0
0176C:  CALL   0DEC
01770:  MOVFF  10D,115
01774:  MOVLW  1B
01776:  MOVLB  1
01778:  MOVWF  x16
0177A:  MOVLB  0
0177C:  CALL   0E4C
01780:  MOVLW  0A
01782:  CLRWDT
01784:  BTFSS  FA4.4
01786:  BRA    1782
01788:  MOVWF  F6D
0178A:  MOVLW  0D
0178C:  CLRWDT
0178E:  BTFSS  FA4.4
01790:  BRA    178C
01792:  MOVWF  F6D
....................                      delay_ms(2); 
01794:  MOVLW  02
01796:  MOVLB  1
01798:  MOVWF  x29
0179A:  MOVLB  0
0179C:  CALL   0964
....................                      data = read_ext_eeprom(14); 
017A0:  MOVLB  1
017A2:  CLRF   x18
017A4:  CLRF   x17
017A6:  CLRF   x16
017A8:  MOVLW  0E
017AA:  MOVWF  x15
017AC:  MOVLB  0
017AE:  CALL   0A12
017B2:  MOVFF  01,10D
....................                      fprintf(PORT2,"Tempo Percurso G3 -> G2 [seg]=%u\n\r",data); 
017B6:  MOVLW  BC
017B8:  MOVWF  FF6
017BA:  MOVLW  04
017BC:  MOVWF  FF7
017BE:  MOVLW  00
017C0:  MOVWF  FF8
017C2:  MOVLW  1E
017C4:  MOVLB  1
017C6:  MOVWF  x15
017C8:  MOVLB  0
017CA:  CALL   0DEC
017CE:  MOVFF  10D,115
017D2:  MOVLW  1B
017D4:  MOVLB  1
017D6:  MOVWF  x16
017D8:  MOVLB  0
017DA:  CALL   0E4C
017DE:  MOVLW  0A
017E0:  CLRWDT
017E2:  BTFSS  FA4.4
017E4:  BRA    17E0
017E6:  MOVWF  F6D
017E8:  MOVLW  0D
017EA:  CLRWDT
017EC:  BTFSS  FA4.4
017EE:  BRA    17EA
017F0:  MOVWF  F6D
....................                      delay_ms(2); 
017F2:  MOVLW  02
017F4:  MOVLB  1
017F6:  MOVWF  x29
017F8:  MOVLB  0
017FA:  CALL   0964
....................                      data = read_ext_eeprom(15); 
017FE:  MOVLB  1
01800:  CLRF   x18
01802:  CLRF   x17
01804:  CLRF   x16
01806:  MOVLW  0F
01808:  MOVWF  x15
0180A:  MOVLB  0
0180C:  CALL   0A12
01810:  MOVFF  01,10D
....................                      fprintf(PORT2,"Timeout Desbloqueio=%u\n\r",data); 
01814:  MOVLW  E0
01816:  MOVWF  FF6
01818:  MOVLW  04
0181A:  MOVWF  FF7
0181C:  MOVLW  00
0181E:  MOVWF  FF8
01820:  MOVLW  14
01822:  MOVLB  1
01824:  MOVWF  x15
01826:  MOVLB  0
01828:  CALL   0DEC
0182C:  MOVFF  10D,115
01830:  MOVLW  1B
01832:  MOVLB  1
01834:  MOVWF  x16
01836:  MOVLB  0
01838:  CALL   0E4C
0183C:  MOVLW  0A
0183E:  CLRWDT
01840:  BTFSS  FA4.4
01842:  BRA    183E
01844:  MOVWF  F6D
01846:  MOVLW  0D
01848:  CLRWDT
0184A:  BTFSS  FA4.4
0184C:  BRA    1848
0184E:  MOVWF  F6D
....................                      delay_ms(2); 
01850:  MOVLW  02
01852:  MOVLB  1
01854:  MOVWF  x29
01856:  MOVLB  0
01858:  CALL   0964
....................                      if(!debug) 
0185C:  BTFSC  xD5.4
0185E:  BRA    1872
....................                         fprintf(PORT2,"Debug=Desabilitado\n\r"); 
01860:  MOVLW  FA
01862:  MOVWF  FF6
01864:  MOVLW  04
01866:  MOVWF  FF7
01868:  MOVLW  00
0186A:  MOVWF  FF8
0186C:  CALL   09B4
01870:  BRA    1882
....................                      else 
....................                         fprintf(PORT2,"Debug=Habilitado\n\r");  
01872:  MOVLW  10
01874:  MOVWF  FF6
01876:  MOVLW  05
01878:  MOVWF  FF7
0187A:  MOVLW  00
0187C:  MOVWF  FF8
0187E:  CALL   09B4
....................                     if(!debugInputs) 
01882:  BTFSC  xD5.5
01884:  BRA    1898
....................                         fprintf(PORT2,"Debug Inputs=Desabilitado\n\r"); 
01886:  MOVLW  24
01888:  MOVWF  FF6
0188A:  MOVLW  05
0188C:  MOVWF  FF7
0188E:  MOVLW  00
01890:  MOVWF  FF8
01892:  CALL   09B4
01896:  BRA    18A8
....................                      else 
....................                         fprintf(PORT2,"Debug Inputs=Habilitado\n\r");  
01898:  MOVLW  40
0189A:  MOVWF  FF6
0189C:  MOVLW  05
0189E:  MOVWF  FF7
018A0:  MOVLW  00
018A2:  MOVWF  FF8
018A4:  CALL   09B4
....................                     } 
....................                break; 
018A8:  BRA    1C34
....................       case 'V':if(LinhaComando) 
018AA:  BTFSS  xD5.2
018AC:  BRA    18D8
....................                   if(Data_Buffer[2]=='S' && Data_Buffer[3]==13)  
018AE:  MOVF   xCF,W
018B0:  SUBLW  53
018B2:  BNZ   18D8
018B4:  MOVF   xD0,W
018B6:  SUBLW  0D
018B8:  BNZ   18D8
....................                     { 
....................                      fprintf(PORT2,"%s",description); 
018BA:  CLRF   FEA
018BC:  MOVLW  22
018BE:  MOVWF  FE9
018C0:  CALL   0ED0
....................                      fprintf(PORT2,"%s",version); 
018C4:  CLRF   FEA
018C6:  MOVLW  45
018C8:  MOVWF  FE9
018CA:  CALL   0ED0
....................                      fprintf(PORT2,"%s",datasw); 
018CE:  CLRF   FEA
018D0:  MOVLW  59
018D2:  MOVWF  FE9
018D4:  CALL   0ED0
....................                     } 
....................                break; 
018D8:  BRA    1C34
....................       case 'a':if(LinhaComando) 
018DA:  BTFSS  xD5.2
018DC:  BRA    18FC
....................                  {if(Data_Buffer[2]=='0' && Data_Buffer[3]==13) 
018DE:  MOVF   xCF,W
018E0:  SUBLW  30
018E2:  BNZ   18EE
018E4:  MOVF   xD0,W
018E6:  SUBLW  0D
018E8:  BNZ   18EE
....................                      debug=0; 
018EA:  BCF    xD5.4
018EC:  BRA    18FC
....................                   else 
....................                     if(Data_Buffer[2]=='1' && Data_Buffer[3]==13) 
018EE:  MOVF   xCF,W
018F0:  SUBLW  31
018F2:  BNZ   18FC
018F4:  MOVF   xD0,W
018F6:  SUBLW  0D
018F8:  BNZ   18FC
....................                       debug=1; 
018FA:  BSF    xD5.4
....................                  } 
....................                break;  
018FC:  BRA    1C34
....................        case 'b':if(LinhaComando) 
018FE:  BTFSS  xD5.2
01900:  BRA    1920
....................                   {if(Data_Buffer[2]=='0' && Data_Buffer[3]==13) 
01902:  MOVF   xCF,W
01904:  SUBLW  30
01906:  BNZ   1912
01908:  MOVF   xD0,W
0190A:  SUBLW  0D
0190C:  BNZ   1912
....................                       debugInputs=0; 
0190E:  BCF    xD5.5
01910:  BRA    1920
....................                    else 
....................                      if(Data_Buffer[2]=='1' && Data_Buffer[3]==13) 
01912:  MOVF   xCF,W
01914:  SUBLW  31
01916:  BNZ   1920
01918:  MOVF   xD0,W
0191A:  SUBLW  0D
0191C:  BNZ   1920
....................                        debugInputs=1; 
0191E:  BSF    xD5.5
....................                   } 
....................                 break;                      
01920:  BRA    1C34
....................        case 'c': // set data 
....................                //mk41t56_set_date_time(BYTE year, BYTE mth, BYTE date, BYTE dow, BYTE hr, BYTE min, BYTE sec); 
....................                                                                          //sec: 0-59 
....................                                                                          //  min: 0-59 
....................                                                                          //  hour:0-23 
....................                                                                          //  dayOfWeek:01-07 
....................                                                                          //  date:01-31 
....................                                                                          //  moth:01-12 
....................                                                                          // year: 0-99 
....................                if(LinhaComando) 
01922:  BTFSS  xD5.2
01924:  BRA    194E
....................                   if(Data_Buffer[2]==13) 
01926:  MOVF   xCF,W
01928:  SUBLW  0D
0192A:  BNZ   194E
....................                     mk41t56_set_date_time(17,4,25,2,18,30,00); 
0192C:  MOVLW  11
0192E:  MOVLB  1
01930:  MOVWF  x15
01932:  MOVLW  04
01934:  MOVWF  x16
01936:  MOVLW  19
01938:  MOVWF  x17
0193A:  MOVLW  02
0193C:  MOVWF  x18
0193E:  MOVLW  12
01940:  MOVWF  x19
01942:  MOVLW  1E
01944:  MOVWF  x1A
01946:  CLRF   x1B
01948:  MOVLB  0
0194A:  GOTO   0F3C
....................                break; 
0194E:  BRA    1C34
....................       case 'd'://Read data 
....................                //mk41t56_get_date(BYTE &year, BYTE &mth ,BYTE &date, BYTE &dow); 
....................                if(LinhaComando) 
01950:  BTFSS  xD5.2
01952:  BRA    1AEC
....................                   if(Data_Buffer[2]==13) 
01954:  MOVF   xCF,W
01956:  SUBLW  0D
01958:  BTFSS  FD8.2
0195A:  BRA    1AEC
....................                      { 
....................                       mk41t56_get_date(year, mth ,date, dow); 
....................                       fprintf(PORT2,"YEAR=%u\n\r",year); 
*
019FC:  MOVLW  5A
019FE:  MOVWF  FF6
01A00:  MOVLW  05
01A02:  MOVWF  FF7
01A04:  MOVLW  00
01A06:  MOVWF  FF8
01A08:  MOVLW  05
01A0A:  MOVLB  1
01A0C:  MOVWF  x15
01A0E:  MOVLB  0
01A10:  CALL   0DEC
01A14:  MOVFF  10E,115
01A18:  MOVLW  1B
01A1A:  MOVLB  1
01A1C:  MOVWF  x16
01A1E:  MOVLB  0
01A20:  CALL   0E4C
01A24:  MOVLW  0A
01A26:  CLRWDT
01A28:  BTFSS  FA4.4
01A2A:  BRA    1A26
01A2C:  MOVWF  F6D
01A2E:  MOVLW  0D
01A30:  CLRWDT
01A32:  BTFSS  FA4.4
01A34:  BRA    1A30
01A36:  MOVWF  F6D
....................                       fprintf(PORT2,"MONTH=%u\n\r",mth); 
01A38:  MOVLW  64
01A3A:  MOVWF  FF6
01A3C:  MOVLW  05
01A3E:  MOVWF  FF7
01A40:  MOVLW  00
01A42:  MOVWF  FF8
01A44:  MOVLW  06
01A46:  MOVLB  1
01A48:  MOVWF  x15
01A4A:  MOVLB  0
01A4C:  CALL   0DEC
01A50:  MOVFF  10F,115
01A54:  MOVLW  1B
01A56:  MOVLB  1
01A58:  MOVWF  x16
01A5A:  MOVLB  0
01A5C:  CALL   0E4C
01A60:  MOVLW  0A
01A62:  CLRWDT
01A64:  BTFSS  FA4.4
01A66:  BRA    1A62
01A68:  MOVWF  F6D
01A6A:  MOVLW  0D
01A6C:  CLRWDT
01A6E:  BTFSS  FA4.4
01A70:  BRA    1A6C
01A72:  MOVWF  F6D
....................                       fprintf(PORT2,"Date=%u\n\r",date); 
01A74:  MOVLW  70
01A76:  MOVWF  FF6
01A78:  MOVLW  05
01A7A:  MOVWF  FF7
01A7C:  MOVLW  00
01A7E:  MOVWF  FF8
01A80:  MOVLW  05
01A82:  MOVLB  1
01A84:  MOVWF  x15
01A86:  MOVLB  0
01A88:  CALL   0DEC
01A8C:  MOVFF  110,115
01A90:  MOVLW  1B
01A92:  MOVLB  1
01A94:  MOVWF  x16
01A96:  MOVLB  0
01A98:  CALL   0E4C
01A9C:  MOVLW  0A
01A9E:  CLRWDT
01AA0:  BTFSS  FA4.4
01AA2:  BRA    1A9E
01AA4:  MOVWF  F6D
01AA6:  MOVLW  0D
01AA8:  CLRWDT
01AAA:  BTFSS  FA4.4
01AAC:  BRA    1AA8
01AAE:  MOVWF  F6D
....................                       fprintf(PORT2,"DayOfWeek=%u\n\r",dow); 
01AB0:  MOVLW  7A
01AB2:  MOVWF  FF6
01AB4:  MOVLW  05
01AB6:  MOVWF  FF7
01AB8:  MOVLW  00
01ABA:  MOVWF  FF8
01ABC:  MOVLW  0A
01ABE:  MOVLB  1
01AC0:  MOVWF  x15
01AC2:  MOVLB  0
01AC4:  CALL   0DEC
01AC8:  MOVFF  111,115
01ACC:  MOVLW  1B
01ACE:  MOVLB  1
01AD0:  MOVWF  x16
01AD2:  MOVLB  0
01AD4:  CALL   0E4C
01AD8:  MOVLW  0A
01ADA:  CLRWDT
01ADC:  BTFSS  FA4.4
01ADE:  BRA    1ADA
01AE0:  MOVWF  F6D
01AE2:  MOVLW  0D
01AE4:  CLRWDT
01AE6:  BTFSS  FA4.4
01AE8:  BRA    1AE4
01AEA:  MOVWF  F6D
....................                      } 
....................                break;          
01AEC:  BRA    1C34
....................       case 'e'://Read time 
....................                //mk41t56_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
....................                if(LinhaComando) 
01AEE:  BTFSS  xD5.2
01AF0:  BRA    1C34
....................                   if(Data_Buffer[2]==13) 
01AF2:  MOVF   xCF,W
01AF4:  SUBLW  0D
01AF6:  BTFSS  FD8.2
01AF8:  BRA    1C34
....................                      { 
....................                       mk41t56_get_time(hr, min, sec); 
....................                       fprintf(PORT2,"HOUR=%u\n\r",hr); 
*
01B80:  MOVLW  8A
01B82:  MOVWF  FF6
01B84:  MOVLW  05
01B86:  MOVWF  FF7
01B88:  MOVLW  00
01B8A:  MOVWF  FF8
01B8C:  MOVLW  05
01B8E:  MOVLB  1
01B90:  MOVWF  x15
01B92:  MOVLB  0
01B94:  CALL   0DEC
01B98:  MOVFF  112,115
01B9C:  MOVLW  1B
01B9E:  MOVLB  1
01BA0:  MOVWF  x16
01BA2:  MOVLB  0
01BA4:  CALL   0E4C
01BA8:  MOVLW  0A
01BAA:  CLRWDT
01BAC:  BTFSS  FA4.4
01BAE:  BRA    1BAA
01BB0:  MOVWF  F6D
01BB2:  MOVLW  0D
01BB4:  CLRWDT
01BB6:  BTFSS  FA4.4
01BB8:  BRA    1BB4
01BBA:  MOVWF  F6D
....................                       fprintf(PORT2,"MINUTE=%u\n\r",min); 
01BBC:  MOVLW  94
01BBE:  MOVWF  FF6
01BC0:  MOVLW  05
01BC2:  MOVWF  FF7
01BC4:  MOVLW  00
01BC6:  MOVWF  FF8
01BC8:  MOVLW  07
01BCA:  MOVLB  1
01BCC:  MOVWF  x15
01BCE:  MOVLB  0
01BD0:  CALL   0DEC
01BD4:  MOVFF  113,115
01BD8:  MOVLW  1B
01BDA:  MOVLB  1
01BDC:  MOVWF  x16
01BDE:  MOVLB  0
01BE0:  CALL   0E4C
01BE4:  MOVLW  0A
01BE6:  CLRWDT
01BE8:  BTFSS  FA4.4
01BEA:  BRA    1BE6
01BEC:  MOVWF  F6D
01BEE:  MOVLW  0D
01BF0:  CLRWDT
01BF2:  BTFSS  FA4.4
01BF4:  BRA    1BF0
01BF6:  MOVWF  F6D
....................                       fprintf(PORT2,"SECOND=%u\n\r",sec); 
01BF8:  MOVLW  A0
01BFA:  MOVWF  FF6
01BFC:  MOVLW  05
01BFE:  MOVWF  FF7
01C00:  MOVLW  00
01C02:  MOVWF  FF8
01C04:  MOVLW  07
01C06:  MOVLB  1
01C08:  MOVWF  x15
01C0A:  MOVLB  0
01C0C:  CALL   0DEC
01C10:  MOVFF  114,115
01C14:  MOVLW  1B
01C16:  MOVLB  1
01C18:  MOVWF  x16
01C1A:  MOVLB  0
01C1C:  CALL   0E4C
01C20:  MOVLW  0A
01C22:  CLRWDT
01C24:  BTFSS  FA4.4
01C26:  BRA    1C22
01C28:  MOVWF  F6D
01C2A:  MOVLW  0D
01C2C:  CLRWDT
01C2E:  BTFSS  FA4.4
01C30:  BRA    1C2C
01C32:  MOVWF  F6D
....................                      } 
....................                break;        
....................  
....................            //default:ImprimeMSGRS232(0); 
....................            //        break;  
....................         } 
01C34:  GOTO   29E4 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  
.................... Outputs 
.................... Porto A ->RA1 -> LED Ambar (Ethernet) 
....................           RA0 -> LED Verde (Ethernet) 
....................  
.................... Porto B -> RB0 -> Relé 8 
....................  
.................... Porto C -> RC6 -> TX UART1 RS485 
....................            RC5 -> Relé 9 
....................            RC3 -> SCL I2C 
....................            RC1 -> LED Verde CPU     (0V ON) 
....................            RC0 -> LED Vermelho CPU  (0V ON) 
....................  
.................... Porto D -> RD7 -> /CS (Chip Select) SPI 
....................            RD6 -> SCK 
....................            RD4 -> SDO SPI 
....................            RD0 -> Iluminação Display 
....................  
.................... Porto E -> RE7 -> Relé 7  //No manual estava mal 
....................            RE6 -> Relé 6 
....................            RE5 -> Relé 5  // Definir como OUT2 
....................            RE4 -> Relé 4  // Definir OUT1 
....................            RE3 -> Relé 3 
....................            RE2 -> Relé 2 
....................            RE1 -> Relé 0 
....................            RE0 -> Relé 1 
....................  
.................... Porto F -> RF7 -> SEND UART 1 RS485 
....................            RF6 -> RTS UART 2 
....................  
.................... Porto G -> RG4 -> Mosfet 0 
....................            RG3 -> Mosfet 1 
....................            RC2 -> Mosfet 2 
....................            RG1 -> TX UART2 RS232 
....................            RG0 -> Mosfet 3 
....................  
....................  
....................          
....................        
....................  
.................... Inputs 
....................  
.................... Porto A -> RA5 -> Analógica A1 
....................            RA4 -> CTS UART2 RS232 
....................            RA3 -> Input digital, analógica ou com 3.3V/Vref 
....................            RA2 -> Analógica A0 
....................             
....................  
.................... Porto B -> RB5 -> Optoacoplador 7 (0V signal ON) 
....................            RB4 -> Optoacoplador 6 (0V signal ON) 
....................            RB3 -> Optoacoplador 5 (0V signal ON) 
....................            RB2 -> Optoacoplador 1 (0V signal ON) 
....................            RB1 -> Optoacoplador 0 (0V signal ON)  
....................  
.................... Porto C -> RC7 -> RX UART1 RS485 
....................  
.................... Porto D -> RD5 -> SDI SPI 
....................            RD3 -> Optoacoplador 4 (0V signal ON) 
....................            RD2 -> Optoacoplador 3 (0V signal ON) 
....................            RD1 -> Optoacoplador 2 (0V signal ON) 
....................  
.................... Porto F -> RF5 -> Analógica A3 
....................            RF4 -> Analógica A4 
....................            RF3 -> Analógica A5 
....................            RF2 -> Analógica A6 
....................            RF1 -> Analógica A7 
....................            RF0 -> Analógica A2 
....................  
.................... Porto H -> RH7 -> SW1 Inputs Dip Switch 
....................            RH6 -> SW2 Inputs Dip Switch 
....................            RH5 -> SW3 Inputs Dip Switch 
....................            RH4 -> SW4 Inputs Dip Switch 
....................            RH3 -> SW5 Inputs Dip Switch 
....................            RH2 -> SW6 Inputs Dip Switch 
....................            RH1 -> SW7 Inputs Dip Switch 
....................            RH0 -> SW8 Inputs Dip Switch 
....................  
.................... Porto G -> RG2 -> RX UART2 RS232 
....................  
....................  
.................... Bidireccionais (Display, Mem+orias, etc) 
.................... Porto B -> RB7 -> PGC 
....................            RB6 -> PGC 
....................  
.................... Porto C -> RC4 -> SDA I2C 
....................  
.................... Porto G -> RG7 -> Display RS 
....................            RG6 -> Display R/W 
....................            RG5 -> Display E 
....................  
....................  
.................... Porto J -> RJ7 -> Display DB7 
....................            RJ6 -> Display DB6 
....................            RJ5 -> Display DB5 
....................            RJ4 -> Display DB4 
....................            RJ3 -> Display DB3 
....................            RJ2 -> Display DB2 
....................            RJ1 -> Display DB1 
....................            RJ0 -> Display DB0 
....................             
....................  
.................... */ 
....................  
....................  
....................  
.................... void LER_ENTRADAS() 
.................... { 
....................  
.................... //Leitura Espiras Simples 
....................  RESTART_WDT(); 
*
01CDE:  CLRWDT
....................  
....................  //Entradas digitais 
.................... switch(auxI1on){ 
01CE0:  MOVF   xA8,W
01CE2:  BZ    1CEA
01CE4:  XORLW  01
01CE6:  BZ    1CF8
01CE8:  BRA    1D2C
....................       case 0:if(!input(IN1)) 
01CEA:  BTFSC  F81.1
01CEC:  BRA    1CF6
....................                { 
....................                 TimerI1on=0; 
01CEE:  CLRF   x69
01CF0:  CLRF   x68
....................                 auxI1on=1; 
01CF2:  MOVLW  01
01CF4:  MOVWF  xA8
....................                } 
....................              break;   
01CF6:  BRA    1D2C
....................       case 1:if(TimerI1on<10)          //50ms 
01CF8:  MOVF   x69,F
01CFA:  BNZ   1D0E
01CFC:  MOVF   x68,W
01CFE:  SUBLW  09
01D00:  BNC   1D0E
....................                {if(input(IN1)) 
01D02:  BTFSS  F81.1
01D04:  BRA    1D0C
....................                   {auxI1on=0;          //Se houve um pico ou foi um sinal falso 
01D06:  CLRF   xA8
....................                    TimerI1on=0;       
01D08:  CLRF   x69
01D0A:  CLRF   x68
....................                   }             
....................                } 
01D0C:  BRA    1D2C
....................              else 
....................                {if(debugInputs && !ING_I1) 
01D0E:  BTFSS  xD5.5
01D10:  BRA    1D26
01D12:  BTFSC  xC8.0
01D14:  BRA    1D26
....................                   fprintf(PORT2,"Input 1 -> ON\n\r"); 
01D16:  MOVLW  AC
01D18:  MOVWF  FF6
01D1A:  MOVLW  05
01D1C:  MOVWF  FF7
01D1E:  MOVLW  00
01D20:  MOVWF  FF8
01D22:  CALL   09B4
....................                 ING_I1=1;         //Espira de Entrada Ocupada 
01D26:  BSF    xC8.0
....................                 MEM_I1=1; 
01D28:  BSF    xC9.0
....................                 auxI1on=0;          
01D2A:  CLRF   xA8
....................                } 
....................              break; 
....................          } 
....................   
.................... switch(auxI1off){ 
01D2C:  MOVF   xA9,W
01D2E:  BZ    1D36
01D30:  XORLW  01
01D32:  BZ    1D44
01D34:  BRA    1D76
....................       case 0:if(input(IN1)) 
01D36:  BTFSS  F81.1
01D38:  BRA    1D42
....................                { 
....................                 TimerI1off=0; 
01D3A:  CLRF   x6B
01D3C:  CLRF   x6A
....................                 auxI1off=1; 
01D3E:  MOVLW  01
01D40:  MOVWF  xA9
....................                } 
....................              break;   
01D42:  BRA    1D76
....................       case 1:if(TimerI1off<10)          //50ms 
01D44:  MOVF   x6B,F
01D46:  BNZ   1D5A
01D48:  MOVF   x6A,W
01D4A:  SUBLW  09
01D4C:  BNC   1D5A
....................                {if(!input(IN1)) 
01D4E:  BTFSC  F81.1
01D50:  BRA    1D58
....................                   {auxI1off=0;          //Se houve um pico ou foi um sinal falso 
01D52:  CLRF   xA9
....................                    TimerI1off=0;       
01D54:  CLRF   x6B
01D56:  CLRF   x6A
....................                   }             
....................                } 
01D58:  BRA    1D76
....................              else 
....................                {if(debugInputs && ING_I1) 
01D5A:  BTFSS  xD5.5
01D5C:  BRA    1D72
01D5E:  BTFSS  xC8.0
01D60:  BRA    1D72
....................                   fprintf(PORT2,"Input 1 -> OFF\n\r"); 
01D62:  MOVLW  BC
01D64:  MOVWF  FF6
01D66:  MOVLW  05
01D68:  MOVWF  FF7
01D6A:  MOVLW  00
01D6C:  MOVWF  FF8
01D6E:  CALL   09B4
....................                 ING_I1=0;         //Espira de Entrada Ocupada 
01D72:  BCF    xC8.0
....................                 auxI1off=0;          
01D74:  CLRF   xA9
....................                } 
....................              break; 
....................          } 
....................  
.................... switch(auxI2on){ 
01D76:  MOVF   xAA,W
01D78:  BZ    1D80
01D7A:  XORLW  01
01D7C:  BZ    1D8E
01D7E:  BRA    1DC2
....................       case 0:if(!input(IN2)) 
01D80:  BTFSC  F81.2
01D82:  BRA    1D8C
....................                { 
....................                 TimerI2on=0; 
01D84:  CLRF   x6D
01D86:  CLRF   x6C
....................                 auxI2on=1; 
01D88:  MOVLW  01
01D8A:  MOVWF  xAA
....................                } 
....................              break;   
01D8C:  BRA    1DC2
....................       case 1:if(TimerI2on<10)          //50ms 
01D8E:  MOVF   x6D,F
01D90:  BNZ   1DA4
01D92:  MOVF   x6C,W
01D94:  SUBLW  09
01D96:  BNC   1DA4
....................                {if(input(IN2)) 
01D98:  BTFSS  F81.2
01D9A:  BRA    1DA2
....................                   {auxI2on=0;          //Se houve um pico ou foi um sinal falso 
01D9C:  CLRF   xAA
....................                    TimerI2on=0;       
01D9E:  CLRF   x6D
01DA0:  CLRF   x6C
....................                   }             
....................                } 
01DA2:  BRA    1DC2
....................              else 
....................                {if(debugInputs && !ING_I2) 
01DA4:  BTFSS  xD5.5
01DA6:  BRA    1DBC
01DA8:  BTFSC  xC8.1
01DAA:  BRA    1DBC
....................                   fprintf(PORT2,"Input 2-> ON\n\r"); 
01DAC:  MOVLW  CE
01DAE:  MOVWF  FF6
01DB0:  MOVLW  05
01DB2:  MOVWF  FF7
01DB4:  MOVLW  00
01DB6:  MOVWF  FF8
01DB8:  CALL   09B4
....................                 ING_I2=1;         //Espira de Entrada Ocupada 
01DBC:  BSF    xC8.1
....................                 MEM_I2=1;      
01DBE:  BSF    xC9.1
....................                 auxI2on=0;          
01DC0:  CLRF   xAA
....................                } 
....................              break; 
....................          } 
....................   
.................... switch(auxI2off){ 
01DC2:  MOVF   xAB,W
01DC4:  BZ    1DCC
01DC6:  XORLW  01
01DC8:  BZ    1DDA
01DCA:  BRA    1E0C
....................       case 0:if(input(IN2)) 
01DCC:  BTFSS  F81.2
01DCE:  BRA    1DD8
....................                { 
....................                 TimerI2off=0; 
01DD0:  CLRF   x6F
01DD2:  CLRF   x6E
....................                 auxI2off=1; 
01DD4:  MOVLW  01
01DD6:  MOVWF  xAB
....................                } 
....................              break;   
01DD8:  BRA    1E0C
....................       case 1:if(TimerI2off<10)          //50ms 
01DDA:  MOVF   x6F,F
01DDC:  BNZ   1DF0
01DDE:  MOVF   x6E,W
01DE0:  SUBLW  09
01DE2:  BNC   1DF0
....................                {if(!input(IN2)) 
01DE4:  BTFSC  F81.2
01DE6:  BRA    1DEE
....................                   {auxI2off=0;          //Se houve um pico ou foi um sinal falso 
01DE8:  CLRF   xAB
....................                    TimerI2off=0;       
01DEA:  CLRF   x6F
01DEC:  CLRF   x6E
....................                   }             
....................                } 
01DEE:  BRA    1E0C
....................              else 
....................                {if(debugInputs && ING_I2) 
01DF0:  BTFSS  xD5.5
01DF2:  BRA    1E08
01DF4:  BTFSS  xC8.1
01DF6:  BRA    1E08
....................                   fprintf(PORT2,"Input 2-> OFF\n\r"); 
01DF8:  MOVLW  DE
01DFA:  MOVWF  FF6
01DFC:  MOVLW  05
01DFE:  MOVWF  FF7
01E00:  MOVLW  00
01E02:  MOVWF  FF8
01E04:  CALL   09B4
....................                 ING_I2=0;         //Espira de Entrada Ocupada 
01E08:  BCF    xC8.1
....................                 auxI2off=0;          
01E0A:  CLRF   xAB
....................                } 
....................              break; 
....................          } 
....................  
....................  
.................... switch(auxI3on){ 
01E0C:  MOVF   xAC,W
01E0E:  BZ    1E16
01E10:  XORLW  01
01E12:  BZ    1E24
01E14:  BRA    1E58
....................       case 0:if(!input(IN3)) 
01E16:  BTFSC  F83.1
01E18:  BRA    1E22
....................                { 
....................                 TimerI3on=0; 
01E1A:  CLRF   x71
01E1C:  CLRF   x70
....................                 auxI3on=1; 
01E1E:  MOVLW  01
01E20:  MOVWF  xAC
....................                } 
....................              break;   
01E22:  BRA    1E58
....................       case 1:if(TimerI3on<10)          //50ms 
01E24:  MOVF   x71,F
01E26:  BNZ   1E3A
01E28:  MOVF   x70,W
01E2A:  SUBLW  09
01E2C:  BNC   1E3A
....................                {if(input(IN3)) 
01E2E:  BTFSS  F83.1
01E30:  BRA    1E38
....................                   {auxI3on=0;          //Se houve um pico ou foi um sinal falso 
01E32:  CLRF   xAC
....................                    TimerI3on=0;       
01E34:  CLRF   x71
01E36:  CLRF   x70
....................                   }             
....................                } 
01E38:  BRA    1E58
....................              else 
....................                {if(debugInputs && !ING_I3) 
01E3A:  BTFSS  xD5.5
01E3C:  BRA    1E52
01E3E:  BTFSC  xC8.2
01E40:  BRA    1E52
....................                   fprintf(PORT2,"Input 3-> ON\n\r"); 
01E42:  MOVLW  EE
01E44:  MOVWF  FF6
01E46:  MOVLW  05
01E48:  MOVWF  FF7
01E4A:  MOVLW  00
01E4C:  MOVWF  FF8
01E4E:  CALL   09B4
....................                 ING_I3=1;         //Espira de Entrada Ocupada 
01E52:  BSF    xC8.2
....................                 MEM_I3=1; 
01E54:  BSF    xC9.2
....................                 auxI3on=0;          
01E56:  CLRF   xAC
....................                } 
....................              break; 
....................          } 
....................   
.................... switch(auxI3off){ 
01E58:  MOVF   xAD,W
01E5A:  BZ    1E62
01E5C:  XORLW  01
01E5E:  BZ    1E70
01E60:  BRA    1EA2
....................       case 0:if(input(IN3)) 
01E62:  BTFSS  F83.1
01E64:  BRA    1E6E
....................                { 
....................                 TimerI3off=0; 
01E66:  CLRF   x73
01E68:  CLRF   x72
....................                 auxI3off=1; 
01E6A:  MOVLW  01
01E6C:  MOVWF  xAD
....................                } 
....................              break;   
01E6E:  BRA    1EA2
....................       case 1:if(TimerI3off<10)          //50ms 
01E70:  MOVF   x73,F
01E72:  BNZ   1E86
01E74:  MOVF   x72,W
01E76:  SUBLW  09
01E78:  BNC   1E86
....................                {if(!input(IN3)) 
01E7A:  BTFSC  F83.1
01E7C:  BRA    1E84
....................                   {auxI3off=0;          //Se houve um pico ou foi um sinal falso 
01E7E:  CLRF   xAD
....................                    TimerI3off=0;       
01E80:  CLRF   x73
01E82:  CLRF   x72
....................                   }             
....................                } 
01E84:  BRA    1EA2
....................              else 
....................                {if(debugInputs && ING_I3) 
01E86:  BTFSS  xD5.5
01E88:  BRA    1E9E
01E8A:  BTFSS  xC8.2
01E8C:  BRA    1E9E
....................                   fprintf(PORT2,"Input 3-> OFF\n\r"); 
01E8E:  MOVLW  FE
01E90:  MOVWF  FF6
01E92:  MOVLW  05
01E94:  MOVWF  FF7
01E96:  MOVLW  00
01E98:  MOVWF  FF8
01E9A:  CALL   09B4
....................                 ING_I3=0;         //Espira de Entrada Ocupada               
01E9E:  BCF    xC8.2
....................                 auxI3off=0;          
01EA0:  CLRF   xAD
....................                } 
....................              break; 
....................          } 
....................  
....................  
.................... switch(auxI4on){ 
01EA2:  MOVF   xAE,W
01EA4:  BZ    1EAC
01EA6:  XORLW  01
01EA8:  BZ    1EBA
01EAA:  BRA    1EEE
....................       case 0:if(!input(IN4)) 
01EAC:  BTFSC  F83.2
01EAE:  BRA    1EB8
....................                { 
....................                 TimerI4on=0; 
01EB0:  CLRF   x75
01EB2:  CLRF   x74
....................                 auxI4on=1; 
01EB4:  MOVLW  01
01EB6:  MOVWF  xAE
....................                } 
....................              break;   
01EB8:  BRA    1EEE
....................       case 1:if(TimerI4on<10)          //50ms 
01EBA:  MOVF   x75,F
01EBC:  BNZ   1ED0
01EBE:  MOVF   x74,W
01EC0:  SUBLW  09
01EC2:  BNC   1ED0
....................                {if(input(IN4)) 
01EC4:  BTFSS  F83.2
01EC6:  BRA    1ECE
....................                   {auxI4on=0;          //Se houve um pico ou foi um sinal falso 
01EC8:  CLRF   xAE
....................                    TimerI4on=0;       
01ECA:  CLRF   x75
01ECC:  CLRF   x74
....................                   }             
....................                } 
01ECE:  BRA    1EEE
....................              else 
....................                {if(debugInputs && !ING_I4) 
01ED0:  BTFSS  xD5.5
01ED2:  BRA    1EE8
01ED4:  BTFSC  xC8.3
01ED6:  BRA    1EE8
....................                   fprintf(PORT2,"Input 4-> ON\n\r"); 
01ED8:  MOVLW  0E
01EDA:  MOVWF  FF6
01EDC:  MOVLW  06
01EDE:  MOVWF  FF7
01EE0:  MOVLW  00
01EE2:  MOVWF  FF8
01EE4:  CALL   09B4
....................                 ING_I4=1;         //Espira de Entrada Ocupada 
01EE8:  BSF    xC8.3
....................                 MEM_I4=1;    
01EEA:  BSF    xC9.3
....................                 auxI4on=0;          
01EEC:  CLRF   xAE
....................                } 
....................              break; 
....................          } 
....................   
.................... switch(auxI4off){ 
01EEE:  MOVF   xAF,W
01EF0:  BZ    1EF8
01EF2:  XORLW  01
01EF4:  BZ    1F06
01EF6:  BRA    1F38
....................       case 0:if(input(IN4)) 
01EF8:  BTFSS  F83.2
01EFA:  BRA    1F04
....................                { 
....................                 TimerI4off=0; 
01EFC:  CLRF   x77
01EFE:  CLRF   x76
....................                 auxI4off=1; 
01F00:  MOVLW  01
01F02:  MOVWF  xAF
....................                } 
....................              break;   
01F04:  BRA    1F38
....................       case 1:if(TimerI4off<10)          //50ms 
01F06:  MOVF   x77,F
01F08:  BNZ   1F1C
01F0A:  MOVF   x76,W
01F0C:  SUBLW  09
01F0E:  BNC   1F1C
....................                {if(!input(IN4)) 
01F10:  BTFSC  F83.2
01F12:  BRA    1F1A
....................                   {auxI4off=0;          //Se houve um pico ou foi um sinal falso 
01F14:  CLRF   xAF
....................                    TimerI4off=0;       
01F16:  CLRF   x77
01F18:  CLRF   x76
....................                   }             
....................                } 
01F1A:  BRA    1F38
....................              else 
....................                {if(debugInputs && ING_I4) 
01F1C:  BTFSS  xD5.5
01F1E:  BRA    1F34
01F20:  BTFSS  xC8.3
01F22:  BRA    1F34
....................                   fprintf(PORT2,"Input 4-> OFF\n\r"); 
01F24:  MOVLW  1E
01F26:  MOVWF  FF6
01F28:  MOVLW  06
01F2A:  MOVWF  FF7
01F2C:  MOVLW  00
01F2E:  MOVWF  FF8
01F30:  CALL   09B4
....................                 ING_I4=0;         //Espira de Entrada Ocupada 
01F34:  BCF    xC8.3
....................                 auxI4off=0; 
01F36:  CLRF   xAF
....................                } 
....................              break; 
....................          } 
....................  
....................  
.................... switch(auxI5on){ 
01F38:  MOVF   xB0,W
01F3A:  BZ    1F42
01F3C:  XORLW  01
01F3E:  BZ    1F50
01F40:  BRA    1F84
....................       case 0:if(!input(IN5)) 
01F42:  BTFSC  F83.3
01F44:  BRA    1F4E
....................                { 
....................                 TimerI5on=0; 
01F46:  CLRF   x79
01F48:  CLRF   x78
....................                 auxI5on=1; 
01F4A:  MOVLW  01
01F4C:  MOVWF  xB0
....................                } 
....................              break;   
01F4E:  BRA    1F84
....................       case 1:if(TimerI5on<10)          //50ms 
01F50:  MOVF   x79,F
01F52:  BNZ   1F66
01F54:  MOVF   x78,W
01F56:  SUBLW  09
01F58:  BNC   1F66
....................                {if(input(IN5)) 
01F5A:  BTFSS  F83.3
01F5C:  BRA    1F64
....................                   {auxI5on=0;          //Se houve um pico ou foi um sinal falso 
01F5E:  CLRF   xB0
....................                    TimerI5on=0;       
01F60:  CLRF   x79
01F62:  CLRF   x78
....................                   }             
....................                } 
01F64:  BRA    1F84
....................              else 
....................                {if(debugInputs && !ING_I5) 
01F66:  BTFSS  xD5.5
01F68:  BRA    1F7E
01F6A:  BTFSC  xC8.4
01F6C:  BRA    1F7E
....................                   fprintf(PORT2,"Input 5-> ON\n\r"); 
01F6E:  MOVLW  2E
01F70:  MOVWF  FF6
01F72:  MOVLW  06
01F74:  MOVWF  FF7
01F76:  MOVLW  00
01F78:  MOVWF  FF8
01F7A:  CALL   09B4
....................                 ING_I5=1;         //Espira de Entrada Ocupada 
01F7E:  BSF    xC8.4
....................                 MEM_I5=1; 
01F80:  BSF    xC9.4
....................                 auxI5on=0; 
01F82:  CLRF   xB0
....................                } 
....................              break; 
....................          } 
....................   
.................... switch(auxI5off){ 
01F84:  MOVF   xB1,W
01F86:  BZ    1F8E
01F88:  XORLW  01
01F8A:  BZ    1F9C
01F8C:  BRA    1FCE
....................       case 0:if(input(IN5)) 
01F8E:  BTFSS  F83.3
01F90:  BRA    1F9A
....................                { 
....................                 TimerI5off=0; 
01F92:  CLRF   x7B
01F94:  CLRF   x7A
....................                 auxI5off=1; 
01F96:  MOVLW  01
01F98:  MOVWF  xB1
....................                } 
....................              break;   
01F9A:  BRA    1FCE
....................       case 1:if(TimerI5off<10)          //50ms 
01F9C:  MOVF   x7B,F
01F9E:  BNZ   1FB2
01FA0:  MOVF   x7A,W
01FA2:  SUBLW  09
01FA4:  BNC   1FB2
....................                {if(!input(IN5)) 
01FA6:  BTFSC  F83.3
01FA8:  BRA    1FB0
....................                   {auxI5off=0;          //Se houve um pico ou foi um sinal falso 
01FAA:  CLRF   xB1
....................                    TimerI5off=0;       
01FAC:  CLRF   x7B
01FAE:  CLRF   x7A
....................                   }             
....................                } 
01FB0:  BRA    1FCE
....................              else 
....................                {if(debugInputs && ING_I5) 
01FB2:  BTFSS  xD5.5
01FB4:  BRA    1FCA
01FB6:  BTFSS  xC8.4
01FB8:  BRA    1FCA
....................                   fprintf(PORT2,"Input 5-> OFF\n\r"); 
01FBA:  MOVLW  3E
01FBC:  MOVWF  FF6
01FBE:  MOVLW  06
01FC0:  MOVWF  FF7
01FC2:  MOVLW  00
01FC4:  MOVWF  FF8
01FC6:  CALL   09B4
....................                 ING_I5=0;         //Espira de Entrada Ocupada 
01FCA:  BCF    xC8.4
....................                 auxI5off=0;          
01FCC:  CLRF   xB1
....................                  
....................                } 
....................              break; 
....................          } 
....................  
....................  
.................... switch(auxI6on){ 
01FCE:  MOVF   xB2,W
01FD0:  BZ    1FD8
01FD2:  XORLW  01
01FD4:  BZ    1FE6
01FD6:  BRA    201A
....................       case 0:if(!input(IN6)) 
01FD8:  BTFSC  F81.3
01FDA:  BRA    1FE4
....................                { 
....................                 TimerI6on=0; 
01FDC:  CLRF   x7D
01FDE:  CLRF   x7C
....................                 auxI6on=1; 
01FE0:  MOVLW  01
01FE2:  MOVWF  xB2
....................                } 
....................              break;   
01FE4:  BRA    201A
....................       case 1:if(TimerI6on<10)          //50ms 
01FE6:  MOVF   x7D,F
01FE8:  BNZ   1FFC
01FEA:  MOVF   x7C,W
01FEC:  SUBLW  09
01FEE:  BNC   1FFC
....................                {if(input(IN6)) 
01FF0:  BTFSS  F81.3
01FF2:  BRA    1FFA
....................                   {auxI6on=0;          //Se houve um pico ou foi um sinal falso 
01FF4:  CLRF   xB2
....................                    TimerI6on=0;       
01FF6:  CLRF   x7D
01FF8:  CLRF   x7C
....................                   }             
....................                } 
01FFA:  BRA    201A
....................              else 
....................                {if(debugInputs && !ING_I6) 
01FFC:  BTFSS  xD5.5
01FFE:  BRA    2014
02000:  BTFSC  xC8.5
02002:  BRA    2014
....................                   fprintf(PORT2,"Input 6-> ON\n\r"); 
02004:  MOVLW  4E
02006:  MOVWF  FF6
02008:  MOVLW  06
0200A:  MOVWF  FF7
0200C:  MOVLW  00
0200E:  MOVWF  FF8
02010:  CALL   09B4
....................                 ING_I6=1;         //Espira de Entrada Ocupada 
02014:  BSF    xC8.5
....................                 MEM_I6=1; 
02016:  BSF    xC9.5
....................                 auxI6on=0;  
02018:  CLRF   xB2
....................                } 
....................              break; 
....................          } 
....................   
.................... switch(auxI6off){ 
0201A:  MOVF   xB3,W
0201C:  BZ    2024
0201E:  XORLW  01
02020:  BZ    2032
02022:  BRA    2064
....................       case 0:if(input(IN6)) 
02024:  BTFSS  F81.3
02026:  BRA    2030
....................                { 
....................                 TimerI6off=0; 
02028:  CLRF   x7F
0202A:  CLRF   x7E
....................                 auxI6off=1; 
0202C:  MOVLW  01
0202E:  MOVWF  xB3
....................                } 
....................              break;   
02030:  BRA    2064
....................       case 1:if(TimerI6off<10)          //50ms 
02032:  MOVF   x7F,F
02034:  BNZ   2048
02036:  MOVF   x7E,W
02038:  SUBLW  09
0203A:  BNC   2048
....................                {if(!input(IN6)) 
0203C:  BTFSC  F81.3
0203E:  BRA    2046
....................                   {auxI6off=0;          //Se houve um pico ou foi um sinal falso 
02040:  CLRF   xB3
....................                    TimerI6off=0;       
02042:  CLRF   x7F
02044:  CLRF   x7E
....................                   }             
....................                } 
02046:  BRA    2064
....................              else 
....................                {if(debugInputs && ING_I6) 
02048:  BTFSS  xD5.5
0204A:  BRA    2060
0204C:  BTFSS  xC8.5
0204E:  BRA    2060
....................                   fprintf(PORT2,"Input 6-> OFF\n\r"); 
02050:  MOVLW  5E
02052:  MOVWF  FF6
02054:  MOVLW  06
02056:  MOVWF  FF7
02058:  MOVLW  00
0205A:  MOVWF  FF8
0205C:  CALL   09B4
....................                 ING_I6=0;         //Espira de Entrada Ocupada 
02060:  BCF    xC8.5
....................                 auxI6off=0;   
02062:  CLRF   xB3
....................                } 
....................              break; 
....................          } 
....................  
....................  
.................... switch(auxI7on){ 
02064:  MOVF   xB4,W
02066:  BZ    206E
02068:  XORLW  01
0206A:  BZ    207C
0206C:  BRA    20B0
....................       case 0:if(!input(IN7)) 
0206E:  BTFSC  F81.4
02070:  BRA    207A
....................                { 
....................                 TimerI7on=0; 
02072:  CLRF   x81
02074:  CLRF   x80
....................                 auxI7on=1; 
02076:  MOVLW  01
02078:  MOVWF  xB4
....................                } 
....................              break;   
0207A:  BRA    20B0
....................       case 1:if(TimerI7on<10)          //50ms 
0207C:  MOVF   x81,F
0207E:  BNZ   2092
02080:  MOVF   x80,W
02082:  SUBLW  09
02084:  BNC   2092
....................                {if(input(IN7)) 
02086:  BTFSS  F81.4
02088:  BRA    2090
....................                   {auxI7on=0;          //Se houve um pico ou foi um sinal falso 
0208A:  CLRF   xB4
....................                    TimerI7on=0;       
0208C:  CLRF   x81
0208E:  CLRF   x80
....................                   }             
....................                } 
02090:  BRA    20B0
....................              else 
....................                {if(debugInputs && !ING_I7) 
02092:  BTFSS  xD5.5
02094:  BRA    20AA
02096:  BTFSC  xC8.6
02098:  BRA    20AA
....................                   fprintf(PORT2,"Input 7-> ON\n\r"); 
0209A:  MOVLW  6E
0209C:  MOVWF  FF6
0209E:  MOVLW  06
020A0:  MOVWF  FF7
020A2:  MOVLW  00
020A4:  MOVWF  FF8
020A6:  CALL   09B4
....................                 ING_I7=1;         //Espira de Entrada Ocupada 
020AA:  BSF    xC8.6
....................                 MEM_I7=1; 
020AC:  BSF    xC9.6
....................                 auxI7on=0; 
020AE:  CLRF   xB4
....................                } 
....................              break; 
....................          } 
....................   
.................... switch(auxI7off){ 
020B0:  MOVF   xB5,W
020B2:  BZ    20BA
020B4:  XORLW  01
020B6:  BZ    20C8
020B8:  BRA    20FA
....................       case 0:if(input(IN7)) 
020BA:  BTFSS  F81.4
020BC:  BRA    20C6
....................                { 
....................                 TimerI7off=0; 
020BE:  CLRF   x83
020C0:  CLRF   x82
....................                 auxI7off=1; 
020C2:  MOVLW  01
020C4:  MOVWF  xB5
....................                } 
....................              break;   
020C6:  BRA    20FA
....................       case 1:if(TimerI7off<10)          //50ms 
020C8:  MOVF   x83,F
020CA:  BNZ   20DE
020CC:  MOVF   x82,W
020CE:  SUBLW  09
020D0:  BNC   20DE
....................                {if(!input(IN7)) 
020D2:  BTFSC  F81.4
020D4:  BRA    20DC
....................                   {auxI7off=0;          //Se houve um pico ou foi um sinal falso 
020D6:  CLRF   xB5
....................                    TimerI7off=0;       
020D8:  CLRF   x83
020DA:  CLRF   x82
....................                   }             
....................                } 
020DC:  BRA    20FA
....................              else 
....................                {if(debugInputs && ING_I7) 
020DE:  BTFSS  xD5.5
020E0:  BRA    20F6
020E2:  BTFSS  xC8.6
020E4:  BRA    20F6
....................                   fprintf(PORT2,"Input 7-> OFF\n\r"); 
020E6:  MOVLW  7E
020E8:  MOVWF  FF6
020EA:  MOVLW  06
020EC:  MOVWF  FF7
020EE:  MOVLW  00
020F0:  MOVWF  FF8
020F2:  CALL   09B4
....................                 ING_I7=0;         //Espira de Entrada Ocupada 
020F6:  BCF    xC8.6
....................                 auxI7off=0;     
020F8:  CLRF   xB5
....................                } 
....................              break; 
....................          } 
....................  
....................  
.................... switch(auxI8on){ 
020FA:  MOVF   xB6,W
020FC:  BZ    2104
020FE:  XORLW  01
02100:  BZ    2112
02102:  BRA    2146
....................       case 0:if(!input(IN8)) 
02104:  BTFSC  F81.5
02106:  BRA    2110
....................                { 
....................                 TimerI8on=0; 
02108:  CLRF   x85
0210A:  CLRF   x84
....................                 auxI8on=1; 
0210C:  MOVLW  01
0210E:  MOVWF  xB6
....................                } 
....................              break;   
02110:  BRA    2146
....................       case 1:if(TimerI8on<10)          //50ms 
02112:  MOVF   x85,F
02114:  BNZ   2128
02116:  MOVF   x84,W
02118:  SUBLW  09
0211A:  BNC   2128
....................                {if(input(IN8)) 
0211C:  BTFSS  F81.5
0211E:  BRA    2126
....................                   {auxI8on=0;          //Se houve um pico ou foi um sinal falso 
02120:  CLRF   xB6
....................                    TimerI8on=0;       
02122:  CLRF   x85
02124:  CLRF   x84
....................                   }             
....................                } 
02126:  BRA    2146
....................              else 
....................                {if(debugInputs && !ING_I8) 
02128:  BTFSS  xD5.5
0212A:  BRA    2140
0212C:  BTFSC  xC8.7
0212E:  BRA    2140
....................                   fprintf(PORT2,"Input 8-> ON\n\r"); 
02130:  MOVLW  8E
02132:  MOVWF  FF6
02134:  MOVLW  06
02136:  MOVWF  FF7
02138:  MOVLW  00
0213A:  MOVWF  FF8
0213C:  CALL   09B4
....................                 ING_I8=1;         //Espira de Entrada Ocupada 
02140:  BSF    xC8.7
....................                 MEM_I8=1; 
02142:  BSF    xC9.7
....................                 auxI8on=0;          
02144:  CLRF   xB6
....................                } 
....................              break; 
....................          } 
....................   
.................... switch(auxI8off){ 
02146:  MOVF   xB7,W
02148:  BZ    2150
0214A:  XORLW  01
0214C:  BZ    215E
0214E:  BRA    2190
....................       case 0:if(input(IN8)) 
02150:  BTFSS  F81.5
02152:  BRA    215C
....................                { 
....................                 TimerI8off=0; 
02154:  CLRF   x87
02156:  CLRF   x86
....................                 auxI8off=1; 
02158:  MOVLW  01
0215A:  MOVWF  xB7
....................                } 
....................              break;   
0215C:  BRA    2190
....................       case 1:if(TimerI8off<10)          //50ms 
0215E:  MOVF   x87,F
02160:  BNZ   2174
02162:  MOVF   x86,W
02164:  SUBLW  09
02166:  BNC   2174
....................                {if(!input(IN8)) 
02168:  BTFSC  F81.5
0216A:  BRA    2172
....................                   {auxI8off=0;          //Se houve um pico ou foi um sinal falso 
0216C:  CLRF   xB7
....................                    TimerI8off=0;       
0216E:  CLRF   x87
02170:  CLRF   x86
....................                   }             
....................                } 
02172:  BRA    2190
....................              else 
....................                {if(debugInputs && ING_I8) 
02174:  BTFSS  xD5.5
02176:  BRA    218C
02178:  BTFSS  xC8.7
0217A:  BRA    218C
....................                   fprintf(PORT2,"Input 8-> OFF\n\r"); 
0217C:  MOVLW  9E
0217E:  MOVWF  FF6
02180:  MOVLW  06
02182:  MOVWF  FF7
02184:  MOVLW  00
02186:  MOVWF  FF8
02188:  CALL   09B4
....................                 ING_I8=0;         //Espira de Entrada Ocupada 
0218C:  BCF    xC8.7
....................                 auxI8off=0;          
0218E:  CLRF   xB7
....................                } 
....................              break; 
....................          } 
....................  
....................  
.................... switch(auxI9on){ 
02190:  MOVF   xB8,W
02192:  BZ    219A
02194:  XORLW  01
02196:  BZ    21A8
02198:  BRA    21DC
....................       case 0:if(input(IN9)) 
0219A:  BTFSS  F80.2
0219C:  BRA    21A6
....................                { 
....................                 TimerI9on=0; 
0219E:  CLRF   x89
021A0:  CLRF   x88
....................                 auxI9on=1; 
021A2:  MOVLW  01
021A4:  MOVWF  xB8
....................                } 
....................              break;   
021A6:  BRA    21DC
....................       case 1:if(TimerI9on<10)          //50ms 
021A8:  MOVF   x89,F
021AA:  BNZ   21BE
021AC:  MOVF   x88,W
021AE:  SUBLW  09
021B0:  BNC   21BE
....................                {if(!input(IN9)) 
021B2:  BTFSC  F80.2
021B4:  BRA    21BC
....................                   {auxI9on=0;          //Se houve um pico ou foi um sinal falso 
021B6:  CLRF   xB8
....................                    TimerI9on=0;       
021B8:  CLRF   x89
021BA:  CLRF   x88
....................                   }             
....................                } 
021BC:  BRA    21DC
....................              else 
....................                {if(debugInputs && !ING_I9) 
021BE:  BTFSS  xD5.5
021C0:  BRA    21D6
021C2:  BTFSC  xCA.0
021C4:  BRA    21D6
....................                   fprintf(PORT2,"Input 9-> ON\n\r"); 
021C6:  MOVLW  AE
021C8:  MOVWF  FF6
021CA:  MOVLW  06
021CC:  MOVWF  FF7
021CE:  MOVLW  00
021D0:  MOVWF  FF8
021D2:  CALL   09B4
....................                 ING_I9=1;         //Espira de Entrada Ocupada 
021D6:  BSF    xCA.0
....................                 MEM_I9=1; 
021D8:  BSF    xCB.0
....................                 auxI9on=0;          
021DA:  CLRF   xB8
....................                } 
....................              break; 
....................          } 
....................   
.................... switch(auxI9off){ 
021DC:  MOVF   xB9,W
021DE:  BZ    21E6
021E0:  XORLW  01
021E2:  BZ    21F4
021E4:  BRA    2226
....................       case 0:if(!input(IN9)) 
021E6:  BTFSC  F80.2
021E8:  BRA    21F2
....................                { 
....................                 TimerI9off=0; 
021EA:  CLRF   x8B
021EC:  CLRF   x8A
....................                 auxI9off=1; 
021EE:  MOVLW  01
021F0:  MOVWF  xB9
....................                } 
....................              break;   
021F2:  BRA    2226
....................       case 1:if(TimerI9off<10)          //50ms 
021F4:  MOVF   x8B,F
021F6:  BNZ   220A
021F8:  MOVF   x8A,W
021FA:  SUBLW  09
021FC:  BNC   220A
....................                {if(input(IN9)) 
021FE:  BTFSS  F80.2
02200:  BRA    2208
....................                   {auxI9off=0;          //Se houve um pico ou foi um sinal falso 
02202:  CLRF   xB9
....................                    TimerI9off=0;       
02204:  CLRF   x8B
02206:  CLRF   x8A
....................                   }             
....................                } 
02208:  BRA    2226
....................              else 
....................                {if(debugInputs && ING_I9) 
0220A:  BTFSS  xD5.5
0220C:  BRA    2222
0220E:  BTFSS  xCA.0
02210:  BRA    2222
....................                   fprintf(PORT2,"Input 9-> OFF\n\r"); 
02212:  MOVLW  BE
02214:  MOVWF  FF6
02216:  MOVLW  06
02218:  MOVWF  FF7
0221A:  MOVLW  00
0221C:  MOVWF  FF8
0221E:  CALL   09B4
....................                 ING_I9=0;         //Espira de Entrada Ocupada 
02222:  BCF    xCA.0
....................                 auxI9off=0;          
02224:  CLRF   xB9
....................                } 
....................              break; 
....................          } 
....................  switch(auxI10on){ 
02226:  MOVF   xBA,W
02228:  BZ    2230
0222A:  XORLW  01
0222C:  BZ    223E
0222E:  BRA    2272
....................       case 0:if(input(IN10)) 
02230:  BTFSS  F80.5
02232:  BRA    223C
....................                { 
....................                 TimerI10on=0; 
02234:  CLRF   x8D
02236:  CLRF   x8C
....................                 auxI10on=1; 
02238:  MOVLW  01
0223A:  MOVWF  xBA
....................                } 
....................              break;   
0223C:  BRA    2272
....................       case 1:if(TimerI10on<10)          //50ms 
0223E:  MOVF   x8D,F
02240:  BNZ   2254
02242:  MOVF   x8C,W
02244:  SUBLW  09
02246:  BNC   2254
....................                {if(!input(IN10)) 
02248:  BTFSC  F80.5
0224A:  BRA    2252
....................                   {auxI10on=0;          //Se houve um pico ou foi um sinal falso 
0224C:  CLRF   xBA
....................                    TimerI10on=0;       
0224E:  CLRF   x8D
02250:  CLRF   x8C
....................                   }             
....................                } 
02252:  BRA    2272
....................              else 
....................                {if(debugInputs && !ING_I10) 
02254:  BTFSS  xD5.5
02256:  BRA    226C
02258:  BTFSC  xCA.1
0225A:  BRA    226C
....................                   fprintf(PORT2,"Input 10-> ON\n\r"); 
0225C:  MOVLW  CE
0225E:  MOVWF  FF6
02260:  MOVLW  06
02262:  MOVWF  FF7
02264:  MOVLW  00
02266:  MOVWF  FF8
02268:  CALL   09B4
....................                 ING_I10=1;         //Espira de Entrada Ocupada 
0226C:  BSF    xCA.1
....................                 MEM_I10=1; 
0226E:  BSF    xCB.1
....................                 auxI10on=0;          
02270:  CLRF   xBA
....................                } 
....................              break; 
....................          }         
.................... switch(auxI10off){ 
02272:  MOVF   xBB,W
02274:  BZ    227C
02276:  XORLW  01
02278:  BZ    228A
0227A:  BRA    22BC
....................       case 0:if(!input(IN10)) 
0227C:  BTFSC  F80.5
0227E:  BRA    2288
....................                { 
....................                 TimerI10off=0; 
02280:  CLRF   x8F
02282:  CLRF   x8E
....................                 auxI10off=1; 
02284:  MOVLW  01
02286:  MOVWF  xBB
....................                } 
....................              break;   
02288:  BRA    22BC
....................       case 1:if(TimerI10off<10)          //50ms 
0228A:  MOVF   x8F,F
0228C:  BNZ   22A0
0228E:  MOVF   x8E,W
02290:  SUBLW  09
02292:  BNC   22A0
....................                {if(input(IN10)) 
02294:  BTFSS  F80.5
02296:  BRA    229E
....................                   {auxI10off=0;          //Se houve um pico ou foi um sinal falso 
02298:  CLRF   xBB
....................                    TimerI10off=0;       
0229A:  CLRF   x8F
0229C:  CLRF   x8E
....................                   }             
....................                } 
0229E:  BRA    22BC
....................              else 
....................                {if(debugInputs && ING_I10) 
022A0:  BTFSS  xD5.5
022A2:  BRA    22B8
022A4:  BTFSS  xCA.1
022A6:  BRA    22B8
....................                   fprintf(PORT2,"Input 10-> OFF\n\r"); 
022A8:  MOVLW  DE
022AA:  MOVWF  FF6
022AC:  MOVLW  06
022AE:  MOVWF  FF7
022B0:  MOVLW  00
022B2:  MOVWF  FF8
022B4:  CALL   09B4
....................                 ING_I10=0;         //Espira de Entrada Ocupada 
022B8:  BCF    xCA.1
....................                 auxI10off=0;          
022BA:  CLRF   xBB
....................                } 
....................              break; 
....................          } 
....................     
....................  switch(auxI11on){ 
022BC:  MOVF   xBC,W
022BE:  BZ    22C6
022C0:  XORLW  01
022C2:  BZ    22D4
022C4:  BRA    2308
....................       case 0:if(input(IN11)) 
022C6:  BTFSS  F85.0
022C8:  BRA    22D2
....................                { 
....................                 TimerI11on=0; 
022CA:  CLRF   x91
022CC:  CLRF   x90
....................                 auxI11on=1; 
022CE:  MOVLW  01
022D0:  MOVWF  xBC
....................                } 
....................              break;   
022D2:  BRA    2308
....................       case 1:if(TimerI11on<10)          //50ms 
022D4:  MOVF   x91,F
022D6:  BNZ   22EA
022D8:  MOVF   x90,W
022DA:  SUBLW  09
022DC:  BNC   22EA
....................                {if(!input(IN11)) 
022DE:  BTFSC  F85.0
022E0:  BRA    22E8
....................                   {auxI11on=0;          //Se houve um pico ou foi um sinal falso 
022E2:  CLRF   xBC
....................                    TimerI11on=0;       
022E4:  CLRF   x91
022E6:  CLRF   x90
....................                   }             
....................                } 
022E8:  BRA    2308
....................              else 
....................                {if(debugInputs && !ING_I11) 
022EA:  BTFSS  xD5.5
022EC:  BRA    2302
022EE:  BTFSC  xCA.2
022F0:  BRA    2302
....................                   fprintf(PORT2,"Input 11-> ON\n\r");   
022F2:  MOVLW  F0
022F4:  MOVWF  FF6
022F6:  MOVLW  06
022F8:  MOVWF  FF7
022FA:  MOVLW  00
022FC:  MOVWF  FF8
022FE:  CALL   09B4
....................                 ING_I11=1;         //Espira de Entrada Ocupada 
02302:  BSF    xCA.2
....................                 MEM_I11=1; 
02304:  BSF    xCB.2
....................                 auxI11on=0;          
02306:  CLRF   xBC
....................                } 
....................              break; 
....................          }            
.................... switch(auxI11off){ 
02308:  MOVF   xBD,W
0230A:  BZ    2312
0230C:  XORLW  01
0230E:  BZ    2320
02310:  BRA    2352
....................       case 0:if(!input(IN11)) 
02312:  BTFSC  F85.0
02314:  BRA    231E
....................                { 
....................                 TimerI11off=0; 
02316:  CLRF   x93
02318:  CLRF   x92
....................                 auxI11off=1; 
0231A:  MOVLW  01
0231C:  MOVWF  xBD
....................                } 
....................              break;   
0231E:  BRA    2352
....................       case 1:if(TimerI11off<10)          //50ms 
02320:  MOVF   x93,F
02322:  BNZ   2336
02324:  MOVF   x92,W
02326:  SUBLW  09
02328:  BNC   2336
....................                {if(input(IN11)) 
0232A:  BTFSS  F85.0
0232C:  BRA    2334
....................                   {auxI11off=0;          //Se houve um pico ou foi um sinal falso 
0232E:  CLRF   xBD
....................                    TimerI11off=0;       
02330:  CLRF   x93
02332:  CLRF   x92
....................                   }             
....................                } 
02334:  BRA    2352
....................              else 
....................                {if(debugInputs && ING_I11) 
02336:  BTFSS  xD5.5
02338:  BRA    234E
0233A:  BTFSS  xCA.2
0233C:  BRA    234E
....................                   fprintf(PORT2,"Input 11-> OFF\n\r");   
0233E:  MOVLW  00
02340:  MOVWF  FF6
02342:  MOVLW  07
02344:  MOVWF  FF7
02346:  MOVLW  00
02348:  MOVWF  FF8
0234A:  CALL   09B4
....................                 ING_I11=0;         //Espira de Entrada Ocupada 
0234E:  BCF    xCA.2
....................                 auxI11off=0;          
02350:  CLRF   xBD
....................                } 
....................              break; 
....................          } 
.................... switch(auxI12on){ 
02352:  MOVF   xBE,W
02354:  BZ    235C
02356:  XORLW  01
02358:  BZ    236A
0235A:  BRA    239E
....................       case 0:if(input(IN12)) 
0235C:  BTFSS  F85.5
0235E:  BRA    2368
....................                { 
....................                 TimerI12on=0; 
02360:  CLRF   x95
02362:  CLRF   x94
....................                 auxI12on=1; 
02364:  MOVLW  01
02366:  MOVWF  xBE
....................                } 
....................              break;   
02368:  BRA    239E
....................       case 1:if(TimerI12on<10)          //50ms 
0236A:  MOVF   x95,F
0236C:  BNZ   2380
0236E:  MOVF   x94,W
02370:  SUBLW  09
02372:  BNC   2380
....................                {if(!input(IN12)) 
02374:  BTFSC  F85.5
02376:  BRA    237E
....................                   {auxI12on=0;          //Se houve um pico ou foi um sinal falso 
02378:  CLRF   xBE
....................                    TimerI12on=0;       
0237A:  CLRF   x95
0237C:  CLRF   x94
....................                   }             
....................                } 
0237E:  BRA    239E
....................              else 
....................                {if(debugInputs && !ING_I12) 
02380:  BTFSS  xD5.5
02382:  BRA    2398
02384:  BTFSC  xCA.3
02386:  BRA    2398
....................                   fprintf(PORT2,"Input 12-> ON\n\r");   
02388:  MOVLW  12
0238A:  MOVWF  FF6
0238C:  MOVLW  07
0238E:  MOVWF  FF7
02390:  MOVLW  00
02392:  MOVWF  FF8
02394:  CALL   09B4
....................                 ING_I12=1;         //Espira de Entrada Ocupada 
02398:  BSF    xCA.3
....................                 MEM_I12=1; 
0239A:  BSF    xCB.3
....................                 auxI12on=0;          
0239C:  CLRF   xBE
....................                } 
....................              break; 
....................          }           
....................           
.................... switch(auxI12off){ 
0239E:  MOVF   xBF,W
023A0:  BZ    23A8
023A2:  XORLW  01
023A4:  BZ    23B6
023A6:  BRA    23E8
....................       case 0:if(!input(IN12)) 
023A8:  BTFSC  F85.5
023AA:  BRA    23B4
....................                { 
....................                 TimerI12off=0; 
023AC:  CLRF   x97
023AE:  CLRF   x96
....................                 auxI12off=1; 
023B0:  MOVLW  01
023B2:  MOVWF  xBF
....................                } 
....................              break;   
023B4:  BRA    23E8
....................       case 1:if(TimerI12off<10)          //50ms 
023B6:  MOVF   x97,F
023B8:  BNZ   23CC
023BA:  MOVF   x96,W
023BC:  SUBLW  09
023BE:  BNC   23CC
....................                {if(input(IN12)) 
023C0:  BTFSS  F85.5
023C2:  BRA    23CA
....................                   {auxI12off=0;          //Se houve um pico ou foi um sinal falso 
023C4:  CLRF   xBF
....................                    TimerI12off=0;       
023C6:  CLRF   x97
023C8:  CLRF   x96
....................                   }             
....................                } 
023CA:  BRA    23E8
....................              else 
....................                {if(debugInputs && ING_I12) 
023CC:  BTFSS  xD5.5
023CE:  BRA    23E4
023D0:  BTFSS  xCA.3
023D2:  BRA    23E4
....................                   fprintf(PORT2,"Input 12-> OFF\n\r");   
023D4:  MOVLW  22
023D6:  MOVWF  FF6
023D8:  MOVLW  07
023DA:  MOVWF  FF7
023DC:  MOVLW  00
023DE:  MOVWF  FF8
023E0:  CALL   09B4
....................                 ING_I12=0;         //Espira de Entrada Ocupada 
023E4:  BCF    xCA.3
....................                 auxI12off=0;          
023E6:  CLRF   xBF
....................                } 
....................              break; 
....................          } 
.................... switch(auxI13on){ 
023E8:  MOVF   xC0,W
023EA:  BZ    23F2
023EC:  XORLW  01
023EE:  BZ    2400
023F0:  BRA    2434
....................       case 0:if(input(IN13)) 
023F2:  BTFSS  F85.4
023F4:  BRA    23FE
....................                { 
....................                 TimerI13on=0; 
023F6:  CLRF   x99
023F8:  CLRF   x98
....................                 auxI13on=1; 
023FA:  MOVLW  01
023FC:  MOVWF  xC0
....................                } 
....................              break;   
023FE:  BRA    2434
....................       case 1:if(TimerI13on<10)          //50ms 
02400:  MOVF   x99,F
02402:  BNZ   2416
02404:  MOVF   x98,W
02406:  SUBLW  09
02408:  BNC   2416
....................                {if(!input(IN13)) 
0240A:  BTFSC  F85.4
0240C:  BRA    2414
....................                   {auxI13on=0;          //Se houve um pico ou foi um sinal falso 
0240E:  CLRF   xC0
....................                    TimerI13on=0;       
02410:  CLRF   x99
02412:  CLRF   x98
....................                   }             
....................                } 
02414:  BRA    2434
....................              else 
....................                {if(debugInputs && !ING_I13) 
02416:  BTFSS  xD5.5
02418:  BRA    242E
0241A:  BTFSC  xCA.4
0241C:  BRA    242E
....................                   fprintf(PORT2,"Input 13-> ON\n\r");   
0241E:  MOVLW  34
02420:  MOVWF  FF6
02422:  MOVLW  07
02424:  MOVWF  FF7
02426:  MOVLW  00
02428:  MOVWF  FF8
0242A:  CALL   09B4
....................                 ING_I13=1;         //Espira de Entrada Ocupada 
0242E:  BSF    xCA.4
....................                 MEM_I13=1; 
02430:  BSF    xCB.4
....................                 auxI13on=0;          
02432:  CLRF   xC0
....................                } 
....................              break; 
....................          }           
.................... switch(auxI13off){ 
02434:  MOVF   xC1,W
02436:  BZ    243E
02438:  XORLW  01
0243A:  BZ    244C
0243C:  BRA    247E
....................       case 0:if(!input(IN13)) 
0243E:  BTFSC  F85.4
02440:  BRA    244A
....................                { 
....................                 TimerI13off=0; 
02442:  CLRF   x9B
02444:  CLRF   x9A
....................                 auxI13off=1; 
02446:  MOVLW  01
02448:  MOVWF  xC1
....................                } 
....................              break;   
0244A:  BRA    247E
....................       case 1:if(TimerI13off<10)          //50ms 
0244C:  MOVF   x9B,F
0244E:  BNZ   2462
02450:  MOVF   x9A,W
02452:  SUBLW  09
02454:  BNC   2462
....................                {if(input(IN13)) 
02456:  BTFSS  F85.4
02458:  BRA    2460
....................                   {auxI13off=0;          //Se houve um pico ou foi um sinal falso 
0245A:  CLRF   xC1
....................                    TimerI13off=0;       
0245C:  CLRF   x9B
0245E:  CLRF   x9A
....................                   }             
....................                } 
02460:  BRA    247E
....................              else 
....................                {if(debugInputs && ING_I13) 
02462:  BTFSS  xD5.5
02464:  BRA    247A
02466:  BTFSS  xCA.4
02468:  BRA    247A
....................                   fprintf(PORT2,"Input 13-> OFF\n\r");   
0246A:  MOVLW  44
0246C:  MOVWF  FF6
0246E:  MOVLW  07
02470:  MOVWF  FF7
02472:  MOVLW  00
02474:  MOVWF  FF8
02476:  CALL   09B4
....................                 ING_I13=0;         //Espira de Entrada Ocupada 
0247A:  BCF    xCA.4
....................                 auxI13off=0;          
0247C:  CLRF   xC1
....................                } 
....................              break; 
....................          } 
.................... switch(auxI14on){ 
0247E:  MOVF   xC2,W
02480:  BZ    2488
02482:  XORLW  01
02484:  BZ    2496
02486:  BRA    24CA
....................       case 0:if(input(IN14)) 
02488:  BTFSS  F85.3
0248A:  BRA    2494
....................                { 
....................                 TimerI14on=0; 
0248C:  CLRF   x9D
0248E:  CLRF   x9C
....................                 auxI14on=1; 
02490:  MOVLW  01
02492:  MOVWF  xC2
....................                } 
....................              break;   
02494:  BRA    24CA
....................       case 1:if(TimerI14on<10)          //50ms 
02496:  MOVF   x9D,F
02498:  BNZ   24AC
0249A:  MOVF   x9C,W
0249C:  SUBLW  09
0249E:  BNC   24AC
....................                {if(!input(IN14)) 
024A0:  BTFSC  F85.3
024A2:  BRA    24AA
....................                   {auxI14on=0;          //Se houve um pico ou foi um sinal falso 
024A4:  CLRF   xC2
....................                    TimerI14on=0;       
024A6:  CLRF   x9D
024A8:  CLRF   x9C
....................                   }             
....................                } 
024AA:  BRA    24CA
....................              else 
....................                {if(debugInputs && !ING_I14) 
024AC:  BTFSS  xD5.5
024AE:  BRA    24C4
024B0:  BTFSC  xCA.5
024B2:  BRA    24C4
....................                   fprintf(PORT2,"Input 14-> ON\n\r");   
024B4:  MOVLW  56
024B6:  MOVWF  FF6
024B8:  MOVLW  07
024BA:  MOVWF  FF7
024BC:  MOVLW  00
024BE:  MOVWF  FF8
024C0:  CALL   09B4
....................                 ING_I14=1;         //Espira de Entrada Ocupada 
024C4:  BSF    xCA.5
....................                 MEM_I14=1; 
024C6:  BSF    xCB.5
....................                 auxI14on=0;          
024C8:  CLRF   xC2
....................                } 
....................              break; 
....................          }           
.................... switch(auxI14off){ 
024CA:  MOVF   xC3,W
024CC:  BZ    24D4
024CE:  XORLW  01
024D0:  BZ    24E2
024D2:  BRA    2514
....................       case 0:if(!input(IN14)) 
024D4:  BTFSC  F85.3
024D6:  BRA    24E0
....................                { 
....................                 TimerI14off=0; 
024D8:  CLRF   x9F
024DA:  CLRF   x9E
....................                 auxI14off=1; 
024DC:  MOVLW  01
024DE:  MOVWF  xC3
....................                } 
....................              break;   
024E0:  BRA    2514
....................       case 1:if(TimerI14off<10)          //50ms 
024E2:  MOVF   x9F,F
024E4:  BNZ   24F8
024E6:  MOVF   x9E,W
024E8:  SUBLW  09
024EA:  BNC   24F8
....................                {if(input(IN14)) 
024EC:  BTFSS  F85.3
024EE:  BRA    24F6
....................                   {auxI14off=0;          //Se houve um pico ou foi um sinal falso 
024F0:  CLRF   xC3
....................                    TimerI14off=0;       
024F2:  CLRF   x9F
024F4:  CLRF   x9E
....................                   }             
....................                } 
024F6:  BRA    2514
....................              else 
....................                {if(debugInputs && ING_I14) 
024F8:  BTFSS  xD5.5
024FA:  BRA    2510
024FC:  BTFSS  xCA.5
024FE:  BRA    2510
....................                   fprintf(PORT2,"Input 14-> OFF\n\r");   
02500:  MOVLW  66
02502:  MOVWF  FF6
02504:  MOVLW  07
02506:  MOVWF  FF7
02508:  MOVLW  00
0250A:  MOVWF  FF8
0250C:  CALL   09B4
....................                 ING_I14=0;         //Espira de Entrada Ocupada 
02510:  BCF    xCA.5
....................                 auxI14off=0;          
02512:  CLRF   xC3
....................                } 
....................              break; 
....................          } 
.................... switch(auxI15on){ 
02514:  MOVF   xC4,W
02516:  BZ    251E
02518:  XORLW  01
0251A:  BZ    252C
0251C:  BRA    2560
....................       case 0:if(input(IN15)) 
0251E:  BTFSS  F85.2
02520:  BRA    252A
....................                { 
....................                 TimerI15on=0; 
02522:  CLRF   xA1
02524:  CLRF   xA0
....................                 auxI15on=1; 
02526:  MOVLW  01
02528:  MOVWF  xC4
....................                } 
....................              break;   
0252A:  BRA    2560
....................       case 1:if(TimerI15on<10)          //50ms 
0252C:  MOVF   xA1,F
0252E:  BNZ   2542
02530:  MOVF   xA0,W
02532:  SUBLW  09
02534:  BNC   2542
....................                {if(!input(IN15)) 
02536:  BTFSC  F85.2
02538:  BRA    2540
....................                   {auxI15on=0;          //Se houve um pico ou foi um sinal falso 
0253A:  CLRF   xC4
....................                    TimerI15on=0;       
0253C:  CLRF   xA1
0253E:  CLRF   xA0
....................                   }             
....................                } 
02540:  BRA    2560
....................              else 
....................                {if(debugInputs && !ING_I15) 
02542:  BTFSS  xD5.5
02544:  BRA    255A
02546:  BTFSC  xCA.6
02548:  BRA    255A
....................                   fprintf(PORT2,"Input 15-> ON\n\r");   
0254A:  MOVLW  78
0254C:  MOVWF  FF6
0254E:  MOVLW  07
02550:  MOVWF  FF7
02552:  MOVLW  00
02554:  MOVWF  FF8
02556:  CALL   09B4
....................                 ING_I15=1;         //Espira de Entrada Ocupada 
0255A:  BSF    xCA.6
....................                 MEM_I15=1; 
0255C:  BSF    xCB.6
....................                 auxI15on=0;          
0255E:  CLRF   xC4
....................                } 
....................              break; 
....................          }           
.................... switch(auxI15off){ 
02560:  MOVF   xC5,W
02562:  BZ    256A
02564:  XORLW  01
02566:  BZ    2578
02568:  BRA    25AA
....................       case 0:if(!input(IN15)) 
0256A:  BTFSC  F85.2
0256C:  BRA    2576
....................                { 
....................                 TimerI15off=0; 
0256E:  CLRF   xA3
02570:  CLRF   xA2
....................                 auxI15off=1; 
02572:  MOVLW  01
02574:  MOVWF  xC5
....................                } 
....................              break;   
02576:  BRA    25AA
....................       case 1:if(TimerI15off<10)          //50ms 
02578:  MOVF   xA3,F
0257A:  BNZ   258E
0257C:  MOVF   xA2,W
0257E:  SUBLW  09
02580:  BNC   258E
....................                {if(input(IN15)) 
02582:  BTFSS  F85.2
02584:  BRA    258C
....................                   {auxI15off=0;          //Se houve um pico ou foi um sinal falso 
02586:  CLRF   xC5
....................                    TimerI15off=0;       
02588:  CLRF   xA3
0258A:  CLRF   xA2
....................                   }             
....................                } 
0258C:  BRA    25AA
....................              else 
....................                {if(debugInputs && ING_I15) 
0258E:  BTFSS  xD5.5
02590:  BRA    25A6
02592:  BTFSS  xCA.6
02594:  BRA    25A6
....................                   fprintf(PORT2,"Input 15-> OFF\n\r");   
02596:  MOVLW  88
02598:  MOVWF  FF6
0259A:  MOVLW  07
0259C:  MOVWF  FF7
0259E:  MOVLW  00
025A0:  MOVWF  FF8
025A2:  CALL   09B4
....................                 ING_I15=0;         //Espira de Entrada Ocupada 
025A6:  BCF    xCA.6
....................                 auxI15off=0;          
025A8:  CLRF   xC5
....................                } 
....................              break; 
....................          } 
.................... switch(auxI16on){ 
025AA:  MOVF   xC6,W
025AC:  BZ    25B4
025AE:  XORLW  01
025B0:  BZ    25C2
025B2:  BRA    25F6
....................       case 0:if(input(IN16)) 
025B4:  BTFSS  F85.1
025B6:  BRA    25C0
....................                { 
....................                 TimerI16on=0; 
025B8:  CLRF   xA5
025BA:  CLRF   xA4
....................                 auxI16on=1; 
025BC:  MOVLW  01
025BE:  MOVWF  xC6
....................                } 
....................              break;   
025C0:  BRA    25F6
....................       case 1:if(TimerI16on<10)          //50ms 
025C2:  MOVF   xA5,F
025C4:  BNZ   25D8
025C6:  MOVF   xA4,W
025C8:  SUBLW  09
025CA:  BNC   25D8
....................                {if(!input(IN16)) 
025CC:  BTFSC  F85.1
025CE:  BRA    25D6
....................                   {auxI16on=0;          //Se houve um pico ou foi um sinal falso 
025D0:  CLRF   xC6
....................                    TimerI16on=0;       
025D2:  CLRF   xA5
025D4:  CLRF   xA4
....................                   }             
....................                } 
025D6:  BRA    25F6
....................              else 
....................                {if(debugInputs && !ING_I16) 
025D8:  BTFSS  xD5.5
025DA:  BRA    25F0
025DC:  BTFSC  xCA.7
025DE:  BRA    25F0
....................                   fprintf(PORT2,"Input 16-> ON\n\r");   
025E0:  MOVLW  9A
025E2:  MOVWF  FF6
025E4:  MOVLW  07
025E6:  MOVWF  FF7
025E8:  MOVLW  00
025EA:  MOVWF  FF8
025EC:  CALL   09B4
....................                 ING_I16=1;         //Espira de Entrada Ocupada 
025F0:  BSF    xCA.7
....................                 MEM_I16=1; 
025F2:  BSF    xCB.7
....................                 auxI16on=0;          
025F4:  CLRF   xC6
....................                } 
....................              break; 
....................          }           
.................... switch(auxI16off){ 
025F6:  MOVF   xC7,W
025F8:  BZ    2600
025FA:  XORLW  01
025FC:  BZ    260E
025FE:  BRA    2640
....................       case 0:if(!input(IN16)) 
02600:  BTFSC  F85.1
02602:  BRA    260C
....................                { 
....................                 TimerI16off=0; 
02604:  CLRF   xA7
02606:  CLRF   xA6
....................                 auxI16off=1; 
02608:  MOVLW  01
0260A:  MOVWF  xC7
....................                } 
....................              break;   
0260C:  BRA    2640
....................       case 1:if(TimerI16off<10)          //50ms 
0260E:  MOVF   xA7,F
02610:  BNZ   2624
02612:  MOVF   xA6,W
02614:  SUBLW  09
02616:  BNC   2624
....................                {if(input(IN16)) 
02618:  BTFSS  F85.1
0261A:  BRA    2622
....................                   {auxI16off=0;          //Se houve um pico ou foi um sinal falso 
0261C:  CLRF   xC7
....................                    TimerI16off=0;       
0261E:  CLRF   xA7
02620:  CLRF   xA6
....................                   }             
....................                } 
02622:  BRA    2640
....................              else 
....................                {if(debugInputs && ING_I16) 
02624:  BTFSS  xD5.5
02626:  BRA    263C
02628:  BTFSS  xCA.7
0262A:  BRA    263C
....................                   fprintf(PORT2,"Input 16-> OFF\n\r");   
0262C:  MOVLW  AA
0262E:  MOVWF  FF6
02630:  MOVLW  07
02632:  MOVWF  FF7
02634:  MOVLW  00
02636:  MOVWF  FF8
02638:  CALL   09B4
....................                 ING_I16=0;         //Espira de Entrada Ocupada 
0263C:  BCF    xCA.7
....................                 auxI16off=0;          
0263E:  CLRF   xC7
....................                } 
....................              break; 
....................          }          
02640:  GOTO   29EA (RETURN)
....................  
....................  
.................... } 
....................  
.................... #define OUT_G1_EV   PIN_E1       //Saída Relé 2 - Semáforo Saída Piso 0   (0->RED, 1->GREEN) 
.................... #define OUT_G2_EV   PIN_E0       //Saída Relé 2 - Semáforo Saída Piso -1  (0->RED, 1->GREEN) 
.................... #define OUT_G3_E    PIN_E2       //Saída Relé 2 - Semáforo Saída Piso -2  (0->OFF, 1->RED) 
.................... #define OUT_G3_V    PIN_E3       //Saída Relé 2 - Semáforo Saída Piso -2  (0->OFF, 1->GREEN) 
.................... #define OUT1        PIN_E4       //Saída Relé 4 - Sinal Inibição Leitor ME 
.................... #define OUT2        PIN_E5       //Saída Relé 5 - Sinal Inibição Leitor MS 
.................... #define OUT3        PIN_E6       //Saída Relé 6 - Sinal Abrir Portão P0 (Entrada) 
.................... #define OUT4        PIN_E7       //Sinal Relé 7 - Sinal Abrir Portão P-1 (Residentes)    
.................... #define OUT5        PIN_B0       //Sinal Relé 8 - Sinal Abrir Barreira P0  
.................... #define OUT6        PIN_C5       //Sinal Relé 9 - Sinal Abrir Barreira P-1 (Auxiliar) 
....................  
....................  
....................  
.................... //0: Verde, 1: Vermelho, 2:Mantêm 
.................... void EstadoGrupos(int8 G1, int8 G2, int8 G3) 
.................... { 
....................  
.................... switch(G1){ 
*
00A74:  MOVLB  1
00A76:  MOVF   x0D,W
00A78:  XORLW  00
00A7A:  MOVLB  0
00A7C:  BZ    0A84
00A7E:  XORLW  01
00A80:  BZ    0A8C
00A82:  BRA    0A94
....................       
....................       case 0:output_low(OUT_G1_EV); 
00A84:  BCF    F8D.1
....................               //Máquina de entrada ativada enquanto Grupo 1 Aberto.               
....................              flagEstadoME=1; 
00A86:  BSF    xD5.6
....................              EstadoG1=0;              // Verde 
00A88:  CLRF   xFB
....................              break;   
00A8A:  BRA    0A94
....................        
....................       case 1:output_high(OUT_G1_EV); 
00A8C:  BSF    F8D.1
....................              //Máquina de fechada enquanto Grupo 1 Aberto. 
....................              flagEstadoME=0; 
00A8E:  BCF    xD5.6
....................              EstadoG1=1;             // Vermelho 
00A90:  MOVLW  01
00A92:  MOVWF  xFB
....................              break; 
....................           }       
....................  
.................... switch(G2){ 
00A94:  MOVLB  1
00A96:  MOVF   x0E,W
00A98:  XORLW  00
00A9A:  MOVLB  0
00A9C:  BZ    0AA4
00A9E:  XORLW  01
00AA0:  BZ    0AAC
00AA2:  BRA    0AB4
....................       case 0:output_low(OUT_G2_EV); 
00AA4:  BCF    F8D.0
....................              flagEstadoMS=1; 
00AA6:  BSF    xD5.7
....................              EstadoG2=0;              // Verde 
00AA8:  CLRF   xFC
....................              break;   
00AAA:  BRA    0AB4
....................       case 1:output_high(OUT_G2_EV); 
00AAC:  BSF    F8D.0
....................              flagEstadoMS=0; 
00AAE:  BCF    xD5.7
....................              EstadoG2=1;             // Vermelho 
00AB0:  MOVLW  01
00AB2:  MOVWF  xFC
....................              break; 
....................           } 
....................  
.................... switch(G3){ 
00AB4:  MOVLB  1
00AB6:  MOVF   x0F,W
00AB8:  XORLW  00
00ABA:  MOVLB  0
00ABC:  BZ    0AC4
00ABE:  XORLW  01
00AC0:  BZ    0ACC
00AC2:  BRA    0AD4
....................       case 0:output_high(OUT_G3_E);        //RED OFF 
00AC4:  BSF    F8D.2
....................              output_low(OUT_G3_V);       //Green ON   
00AC6:  BCF    F8D.3
....................              EstadoG3=0;              // Verde 
00AC8:  CLRF   xFD
....................              break;   
00ACA:  BRA    0AD4
....................       case 1:output_low(OUT_G3_E);        //RED ON 
00ACC:  BCF    F8D.2
....................              output_high(OUT_G3_V);        //Green OFF   
00ACE:  BSF    F8D.3
....................              EstadoG3=1;             // Vermelho 
00AD0:  MOVLW  01
00AD2:  MOVWF  xFD
....................              break; 
....................           } 
00AD4:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void main(void) { 
*
02644:  CLRF   FF8
02646:  BCF    FD0.7
02648:  BSF    07.7
0264A:  CLRF   1B
0264C:  BSF    F7C.3
0264E:  MOVLW  45
02650:  MOVWF  F6F
02652:  MOVLW  01
02654:  MOVWF  F7D
02656:  MOVLW  A6
02658:  MOVWF  F6C
0265A:  MOVLW  90
0265C:  MOVWF  F6B
0265E:  BSF    F94.3
02660:  BSF    F94.4
02662:  MOVLW  3E
02664:  MOVWF  FC8
02666:  MOVLW  28
02668:  MOVWF  FC6
0266A:  BSF    FC7.7
0266C:  BCF    FC7.6
0266E:  CLRF   x69
02670:  CLRF   x68
02672:  CLRF   x6B
02674:  CLRF   x6A
02676:  CLRF   x6D
02678:  CLRF   x6C
0267A:  CLRF   x6F
0267C:  CLRF   x6E
0267E:  CLRF   x71
02680:  CLRF   x70
02682:  CLRF   x73
02684:  CLRF   x72
02686:  CLRF   x75
02688:  CLRF   x74
0268A:  CLRF   x77
0268C:  CLRF   x76
0268E:  CLRF   x79
02690:  CLRF   x78
02692:  CLRF   x7B
02694:  CLRF   x7A
02696:  CLRF   x7D
02698:  CLRF   x7C
0269A:  CLRF   x7F
0269C:  CLRF   x7E
0269E:  CLRF   x81
026A0:  CLRF   x80
026A2:  CLRF   x83
026A4:  CLRF   x82
026A6:  CLRF   x85
026A8:  CLRF   x84
026AA:  CLRF   x87
026AC:  CLRF   x86
026AE:  CLRF   x89
026B0:  CLRF   x88
026B2:  CLRF   x8B
026B4:  CLRF   x8A
026B6:  CLRF   x8D
026B8:  CLRF   x8C
026BA:  CLRF   x8F
026BC:  CLRF   x8E
026BE:  CLRF   x91
026C0:  CLRF   x90
026C2:  CLRF   x93
026C4:  CLRF   x92
026C6:  CLRF   x95
026C8:  CLRF   x94
026CA:  CLRF   x97
026CC:  CLRF   x96
026CE:  CLRF   x99
026D0:  CLRF   x98
026D2:  CLRF   x9B
026D4:  CLRF   x9A
026D6:  CLRF   x9D
026D8:  CLRF   x9C
026DA:  CLRF   x9F
026DC:  CLRF   x9E
026DE:  CLRF   xA1
026E0:  CLRF   xA0
026E2:  CLRF   xA3
026E4:  CLRF   xA2
026E6:  CLRF   xA5
026E8:  CLRF   xA4
026EA:  CLRF   xA7
026EC:  CLRF   xA6
026EE:  CLRF   xA8
026F0:  CLRF   xA9
026F2:  CLRF   xAA
026F4:  CLRF   xAB
026F6:  CLRF   xAC
026F8:  CLRF   xAD
026FA:  CLRF   xAE
026FC:  CLRF   xAF
026FE:  CLRF   xB0
02700:  CLRF   xB1
02702:  CLRF   xB2
02704:  CLRF   xB3
02706:  CLRF   xB4
02708:  CLRF   xB5
0270A:  CLRF   xB6
0270C:  CLRF   xB7
0270E:  CLRF   xB8
02710:  CLRF   xB9
02712:  CLRF   xBA
02714:  CLRF   xBB
02716:  CLRF   xBC
02718:  CLRF   xBD
0271A:  CLRF   xBE
0271C:  CLRF   xBF
0271E:  CLRF   xC0
02720:  CLRF   xC1
02722:  CLRF   xC2
02724:  CLRF   xC3
02726:  CLRF   xC4
02728:  CLRF   xC5
0272A:  CLRF   xC6
0272C:  CLRF   xC7
0272E:  BCF    xC8.0
02730:  BCF    xC8.1
02732:  BCF    xC8.2
02734:  BCF    xC8.3
02736:  BCF    xC8.4
02738:  BCF    xC8.5
0273A:  BCF    xC8.6
0273C:  BCF    xC8.7
0273E:  BCF    xC9.0
02740:  BCF    xC9.1
02742:  BCF    xC9.2
02744:  BCF    xC9.3
02746:  BCF    xC9.4
02748:  BCF    xC9.5
0274A:  BCF    xC9.6
0274C:  BCF    xC9.7
0274E:  BCF    xCA.0
02750:  BCF    xCA.1
02752:  BCF    xCA.2
02754:  BCF    xCA.3
02756:  BCF    xCA.4
02758:  BCF    xCA.5
0275A:  BCF    xCA.6
0275C:  BCF    xCA.7
0275E:  BCF    xCB.0
02760:  BCF    xCB.1
02762:  BCF    xCB.2
02764:  BCF    xCB.3
02766:  BCF    xCB.4
02768:  BCF    xCB.5
0276A:  BCF    xCB.6
0276C:  BCF    xCB.7
0276E:  CLRF   xCC
02770:  CLRF   xD4
02772:  BSF    xD5.0
02774:  BCF    xD5.1
02776:  BCF    xD5.2
02778:  CLRF   xD6
0277A:  CLRF   xD7
0277C:  CLRF   xD8
0277E:  CLRF   xD9
02780:  CLRF   xDA
02782:  CLRF   xDB
02784:  CLRF   xDC
02786:  CLRF   xDD
02788:  CLRF   xDE
0278A:  CLRF   xDF
0278C:  CLRF   xE0
0278E:  CLRF   xE1
02790:  BCF    xD5.3
02792:  CLRF   xFB
02794:  CLRF   xFC
02796:  CLRF   xFD
02798:  CLRF   xFE
0279A:  BCF    xD5.4
0279C:  BCF    xD5.5
0279E:  BCF    xD5.6
027A0:  BCF    xD5.7
027A2:  BCF    xFF.0
027A4:  BCF    xFF.1
027A6:  BCF    xFF.2
027A8:  MOVLB  1
027AA:  CLRF   x01
027AC:  CLRF   x00
027AE:  MOVF   FC1,W
027B0:  ANDLW  C0
027B2:  MOVWF  FC1
027B4:  MOVLW  07
027B6:  MOVWF  FB4
027B8:  BRA    2804
027BA:  DATA 02,00
027BC:  DATA 1C,00
027BE:  DATA 00,21
027C0:  DATA 00,22
027C2:  DATA 53,57
027C4:  DATA 20,75
027C6:  DATA 50,4C
027C8:  DATA 43,20
027CA:  DATA 43,6F
027CC:  DATA 6E,74
027CE:  DATA 69,6E
027D0:  DATA 65,6E
027D2:  DATA 74,65
027D4:  DATA 20,42
027D6:  DATA 6F,63
027D8:  DATA 61,67
027DA:  DATA 65,20
027DC:  DATA 2D,20
027DE:  DATA 4C,58
027E0:  DATA 0D,0A
027E2:  DATA 00,0E
027E4:  DATA 00,45
027E6:  DATA 56,65
027E8:  DATA 72,73
027EA:  DATA 61,6F
027EC:  DATA 20,56
027EE:  DATA 30,2E
027F0:  DATA 38,0D
027F2:  DATA 0A,00
027F4:  DATA 0B,00
027F6:  DATA 59,32
027F8:  DATA 35,2D
027FA:  DATA 30,35
027FC:  DATA 2D,31
027FE:  DATA 37,0D
02800:  DATA 0A,00
02802:  DATA 00,00
02804:  MOVLW  00
02806:  MOVWF  FF8
02808:  MOVLW  27
0280A:  MOVWF  FF7
0280C:  MOVLW  BA
0280E:  MOVWF  FF6
02810:  TBLRD*+
02812:  MOVF   FF5,W
02814:  MOVWF  00
02816:  XORLW  00
02818:  BZ    2840
0281A:  TBLRD*+
0281C:  MOVF   FF5,W
0281E:  MOVWF  01
02820:  BTFSC  FE8.7
02822:  BRA    282E
02824:  ANDLW  0F
02826:  MOVWF  FEA
02828:  TBLRD*+
0282A:  MOVFF  FF5,FE9
0282E:  BTFSC  01.6
02830:  TBLRD*+
02832:  BTFSS  01.6
02834:  TBLRD*+
02836:  MOVFF  FF5,FEE
0283A:  DCFSNZ 00,F
0283C:  BRA    2810
0283E:  BRA    2832
02840:  CLRF   FF8
02842:  CLRF   x05
02844:  CLRF   x06
02846:  CLRF   x07
02848:  CLRF   x08
0284A:  BCF    x04.1
0284C:  BCF    x04.2
0284E:  BCF    x04.3
02850:  BCF    x04.4
02852:  BCF    x04.5
02854:  BCF    x04.6
02856:  BCF    x04.7
02858:  BCF    x09.0
0285A:  BCF    x09.1
0285C:  BCF    x09.2
0285E:  BCF    x09.3
02860:  BCF    x09.4
02862:  BCF    x09.5
02864:  BCF    x09.6
02866:  BCF    x09.7
02868:  BCF    x0A.0
0286A:  BCF    x0A.1
0286C:  BCF    x0A.2
0286E:  BCF    x0A.3
02870:  BCF    x0A.4
02872:  BCF    x0A.5
02874:  BCF    x0A.6
02876:  BCF    x0A.7
02878:  BCF    x0B.0
0287A:  BCF    x0B.1
0287C:  BCF    x0B.2
0287E:  BCF    x0B.3
02880:  BCF    x0B.4
02882:  BCF    x0B.5
02884:  BCF    x0B.6
02886:  BCF    x0B.7
02888:  BCF    x0C.0
0288A:  BCF    x0C.1
0288C:  BCF    x0C.2
.................... int1 id0,id1,id2,id3,id4,id5,id6,id7,ia0,ia1,ia2,ia3,ia4,ia5,ia6,ia7,ia8; 
.................... int8 i=0; 
.................... int8 auxTime=0; 
.................... int8 cleartime=0; 
.................... int8 TIMER_A_OLD=0; 
....................  
.................... int1 aux1=0,aux2=0,aux3=0,aux4=0,aux5=0,aux6=0,aux7=0,aux8=0; 
.................... int1 aux9=0,aux10=0,aux11=0,aux12=0,aux13=0,aux14=0,aux15=0,aux16=0; 
....................  
.................... int1 auxNotRES=0,auxRES=0,auxINTERFON=0,blockENT=0; 
.................... int1 aux_P_RES=0,aux_B_ENT=0,auxNotRESBarAux=0,BarAuxFim=0; 
....................  
.................... int1 ABRE_BARR_ENT=0,ABRE_BARR_AUX=0,ABRE_P_ENT=0,ABRE_P_RES=0; 
.................... int1 PULSO_1=0,PULSO_2=0,PULSO_3=0,PULSO_4=0; 
....................  
.................... int1 auxCheck_in=0;   //((flag para indicar que ouve pedido na ME 
.................... int1 auxBO_open=0; 
....................  
.................... SET_TRIS_A(0b00111100); 
0288E:  MOVLW  3C
02890:  MOVWF  F92
.................... SET_TRIS_B(0b00111110); 
02892:  MOVLW  3E
02894:  MOVWF  F93
....................  
.................... SET_TRIS_D(0b00101110); 
02896:  MOVLW  2E
02898:  MOVWF  F95
.................... SET_TRIS_E(0b00000000); //Coloca o pinos E0~E7 com outputs Relé ON-> Output 0 
0289A:  MOVLW  00
0289C:  MOVWF  F96
.................... SET_TRIS_F(0b00111111); //Coloca o pinos F0~F5 Analógicas, F6 e F7 special outputs 
0289E:  MOVLW  3F
028A0:  MOVWF  F97
.................... SET_TRIS_H(0b11111111); //Coloca o pinos H0~H7 com inputs  SW ON-> Input 0 
028A2:  MOVLW  FF
028A4:  MOVWF  F99
.................... SET_TRIS_J(0b00001111); //Set Tris do display 
028A6:  MOVLW  0F
028A8:  MOVWF  F9A
.................... SETUP_ADC(ADC_OFF); 
028AA:  BCF    FC2.0
.................... setup_adc_ports(NO_ANALOGS); 
028AC:  MOVF   FC1,W
028AE:  ANDLW  C0
028B0:  IORLW  0F
028B2:  MOVWF  FC1
.................... SETUP_WDT(WDT_ON); 
028B4:  BSF    FD1.0
.................... RESTART_WDT(); 
028B6:  CLRWDT
.................... SETUP_TIMER_0(RTCC_INTERNAL|RTCC_DIV_1);  //timer0 16bits 
028B8:  MOVLW  88
028BA:  MOVWF  FD5
.................... SET_TIMER0(34286); 
028BC:  MOVLW  85
028BE:  MOVWF  FD7
028C0:  MOVLW  EE
028C2:  MOVWF  FD6
.................... enable_interrupts(INT_RTCC);               // Habilito Interrupción RTCC 
028C4:  BSF    FF2.5
.................... enable_interrupts(INT_RDA2);               // Habilito Interrupciones RS232 
028C6:  BSF    FA3.5
.................... enable_interrupts(global);                 // Habilito Interrupciones 
028C8:  MOVLW  C0
028CA:  IORWF  FF2,F
.................... SET_TIMER0(34286); 
028CC:  MOVLW  85
028CE:  MOVWF  FD7
028D0:  MOVLW  EE
028D2:  MOVWF  FD6
....................  
....................  
.................... output_high(PIN_C0); 
028D4:  BCF    F94.0
028D6:  BSF    F8B.0
.................... output_low(PIN_C1); 
028D8:  BCF    F94.1
028DA:  BCF    F8B.1
....................  
.................... output_low(PIN_F7);                        //SEND RS485 
028DC:  BCF    F8E.7
....................  
.................... setup_spi2(SPI_MASTER | SPI_L_TO_H |SPI_XMIT_L_TO_H | SPI_CLK_DIV_16); 
028DE:  BCF    F63.5
028E0:  MOVLW  21
028E2:  MOVWF  F63
028E4:  MOVLW  40
028E6:  MOVWF  F64
.................... output_high(EEPROM_SELECT);  
028E8:  BSF    F8C.7
....................  
....................  
.................... RESTART_WDT(); 
028EA:  CLRWDT
.................... //numLSB=read_ext_eeprom(type); 
.................... //write_ext_eeprom(type,numLSB); //Escreve o nº de Parques 
....................  
....................  
....................  
.................... //------------------------Start 
....................  
.................... //OUTPUT_E(0b11111111); 
.................... output_high(PIN_C5); 
028EC:  BCF    F94.5
028EE:  BSF    F8B.5
.................... output_high(PIN_B0); 
028F0:  BSF    F8A.0
....................  
.................... OUTPUT_E(0b11111011); 
028F2:  MOVLW  FB
028F4:  MOVWF  F8D
.................... delay_seg(1); 
028F6:  MOVLW  01
028F8:  MOVWF  x0D
028FA:  MOVLB  0
028FC:  CALL   098E
.................... RESTART_WDT(); 
02900:  CLRWDT
....................  
.................... output_high(PIN_G4); 
02902:  BCF    F98.4
02904:  BSF    F8F.4
.................... output_high(PIN_G3); 
02906:  BCF    F98.3
02908:  BSF    F8F.3
.................... output_high(PIN_G0); 
0290A:  BCF    F98.0
0290C:  BSF    F8F.0
.................... output_high(PIN_C2); 
0290E:  BCF    F94.2
02910:  BSF    F8B.2
.................... RESTART_WDT(); 
02912:  CLRWDT
.................... delay_ms(1000); 
02914:  MOVLW  04
02916:  MOVLB  1
02918:  MOVWF  x0D
0291A:  MOVLW  FA
0291C:  MOVWF  x29
0291E:  MOVLB  0
02920:  CALL   0964
02924:  MOVLB  1
02926:  DECFSZ x0D,F
02928:  BRA    291A
.................... RESTART_WDT(); 
0292A:  CLRWDT
.................... output_low(PIN_G4); 
0292C:  BCF    F98.4
0292E:  BCF    F8F.4
.................... output_low(PIN_G3); 
02930:  BCF    F98.3
02932:  BCF    F8F.3
.................... output_low(PIN_G0); 
02934:  BCF    F98.0
02936:  BCF    F8F.0
.................... output_low(PIN_C2); 
02938:  BCF    F94.2
0293A:  BCF    F8B.2
....................  
.................... fprintf(PORT2,"Inicio de Funcionamento OK\n\r"); 
0293C:  MOVLW  BC
0293E:  MOVWF  FF6
02940:  MOVLW  07
02942:  MOVWF  FF7
02944:  MOVLW  00
02946:  MOVWF  FF8
02948:  MOVLB  0
0294A:  CALL   09B4
....................  
.................... OUTPUT_E(0b11111011); 
0294E:  MOVLW  FB
02950:  MOVWF  F8D
....................  
....................  
.................... ia0=0; 
02952:  MOVLB  1
02954:  BCF    x03.0
.................... ia1=0; 
02956:  BCF    x03.1
.................... ia2=0; 
02958:  BCF    x03.2
.................... ia3=0; 
0295A:  BCF    x03.3
.................... ia4=0; 
0295C:  BCF    x03.4
.................... ia5=0; 
0295E:  BCF    x03.5
.................... ia6=0; 
02960:  BCF    x03.6
.................... ia7=0; 
02962:  BCF    x03.7
.................... ia8=0; 
02964:  BCF    x04.0
....................  
.................... // Testes  -- LOAD TIMES FROM EEPROM 
....................  
.................... for(i=0;i<25;i++) 
02966:  CLRF   x05
02968:  MOVF   x05,W
0296A:  SUBLW  18
0296C:  BNC   29B0
....................   { 
....................    Tempos[i] = read_ext_eeprom(i); 
0296E:  CLRF   03
02970:  MOVF   x05,W
02972:  ADDLW  E2
02974:  MOVWF  01
02976:  MOVLW  00
02978:  ADDWFC 03,F
0297A:  MOVFF  01,10D
0297E:  MOVFF  03,10E
02982:  CLRF   x18
02984:  CLRF   x17
02986:  CLRF   x16
02988:  MOVFF  105,115
0298C:  MOVLB  0
0298E:  CALL   0A12
02992:  MOVFF  10E,FEA
02996:  MOVFF  10D,FE9
0299A:  MOVFF  01,FEF
....................    delay_ms(2); 
0299E:  MOVLW  02
029A0:  MOVLB  1
029A2:  MOVWF  x29
029A4:  MOVLB  0
029A6:  CALL   0964
029AA:  MOVLB  1
029AC:  INCF   x05,F
029AE:  BRA    2968
....................   } 
....................  
.................... delay_seg(1); 
029B0:  MOVLW  01
029B2:  MOVWF  x0D
029B4:  MOVLB  0
029B6:  CALL   098E
....................  
.................... // 
....................  
.................... TIMER_A_OLD = TIMER_A; 
029BA:  MOVFF  DB,108
....................  
.................... EstadoGrupos(0,1,1); //0: Verde, 1:VErmelho,2:Mantêm  //Inicialização semáforos 
029BE:  MOVLB  1
029C0:  CLRF   x0D
029C2:  MOVLW  01
029C4:  MOVWF  x0E
029C6:  MOVWF  x0F
029C8:  MOVLB  0
029CA:  CALL   0A74
....................  
....................  
.................... RESTART_WDT(); 
029CE:  CLRWDT
.................... while(true) 
.................... { 
....................  
....................   if(BufferOK)  //Faz soma de checksum 
029D0:  BTFSS  xD5.1
029D2:  BRA    29E6
....................     { 
....................      delay_ms(50); 
029D4:  MOVLW  32
029D6:  MOVLB  1
029D8:  MOVWF  x29
029DA:  MOVLB  0
029DC:  CALL   0964
....................      trata_buffer(); 
029E0:  GOTO   1032
....................      BufferOK=0; 
029E4:  BCF    xD5.1
....................     }  
....................  
....................  
....................   //--------------------PROGRAM-----------------------------------  
....................  LER_ENTRADAS(); 
029E6:  GOTO   1CDE
....................  RESTART_WDT(); 
029EA:  CLRWDT
....................  
....................  if(TIMER_A_OLD != TIMER_A) 
029EC:  MOVF   xDB,W
029EE:  MOVLB  1
029F0:  SUBWF  x08,W
029F2:  BZ    2A3C
....................    { 
....................    if(debug) 
029F4:  MOVLB  0
029F6:  BTFSS  xD5.4
029F8:  BRA    2A36
....................       fprintf(PORT2,"STEP=%u\n\r",step); 
029FA:  MOVLW  DA
029FC:  MOVWF  FF6
029FE:  MOVLW  07
02A00:  MOVWF  FF7
02A02:  MOVLW  00
02A04:  MOVWF  FF8
02A06:  MOVLW  05
02A08:  MOVLB  1
02A0A:  MOVWF  x15
02A0C:  MOVLB  0
02A0E:  CALL   0DEC
02A12:  MOVFF  FE,115
02A16:  MOVLW  1B
02A18:  MOVLB  1
02A1A:  MOVWF  x16
02A1C:  MOVLB  0
02A1E:  CALL   0E4C
02A22:  MOVLW  0A
02A24:  CLRWDT
02A26:  BTFSS  FA4.4
02A28:  BRA    2A24
02A2A:  MOVWF  F6D
02A2C:  MOVLW  0D
02A2E:  CLRWDT
02A30:  BTFSS  FA4.4
02A32:  BRA    2A2E
02A34:  MOVWF  F6D
....................    TIMER_A_OLD=TIMER_A; 
02A36:  MOVFF  DB,108
02A3A:  MOVLB  1
....................    }                                                                                                                                                                                    
....................  
....................  // ACESSOS  
....................  if(ING_I1 && ING_I8  && !auxINTERFON && flagEstadoME)      // Detecção Residentes com leitor ativo 
02A3C:  MOVLB  0
02A3E:  BTFSS  xC8.0
02A40:  BRA    2A80
02A42:  BTFSS  xC8.7
02A44:  BRA    2A80
02A46:  MOVLB  1
02A48:  BTFSS  x0A.3
02A4A:  BRA    2A50
02A4C:  MOVLB  0
02A4E:  BRA    2A80
02A50:  MOVLB  0
02A52:  BTFSS  xD5.6
02A54:  BRA    2A80
....................    {  
....................      flagBlockI13=1; 
02A56:  BSF    xFF.2
....................      auxINTERFON=1; 
02A58:  MOVLB  1
02A5A:  BSF    x0A.3
....................      if(debug) 
02A5C:  MOVLB  0
02A5E:  BTFSS  xD5.4
02A60:  BRA    2A72
....................        fprintf(PORT2,"Interfonia - Noite. Abrir Barreira, Portão P0 e Portao RES."); 
02A62:  MOVLW  E4
02A64:  MOVWF  FF6
02A66:  MOVLW  07
02A68:  MOVWF  FF7
02A6A:  MOVLW  00
02A6C:  MOVWF  FF8
02A6E:  CALL   09B4
....................      ABRE_P_ENT=1; 
02A72:  MOVLB  1
02A74:  BSF    x0B.3
....................      ABRE_BARR_ENT=1; 
02A76:  BSF    x0B.1
....................      ABRE_P_RES=1; 
02A78:  BSF    x0B.4
....................      auxCheck_in=1; 
02A7A:  BSF    x0C.1
....................    } 
02A7C:  BRA    2AB6
02A7E:  MOVLB  0
....................  else 
....................    if(!ING_I1 && auxINTERFON) 
02A80:  BTFSC  xC8.0
02A82:  BRA    2AB4
02A84:  MOVLB  1
02A86:  BTFSC  x0A.3
02A88:  BRA    2A8E
02A8A:  MOVLB  0
02A8C:  BRA    2AB4
....................      { 
....................       TIMER_G13=Tempos[11]; 
02A8E:  MOVFF  ED,E1
....................       if(debug) 
02A92:  MOVLB  0
02A94:  BTFSS  xD5.4
02A96:  BRA    2AA8
....................         fprintf(PORT2,"Vou carregar o TimerG13"); 
02A98:  MOVLW  20
02A9A:  MOVWF  FF6
02A9C:  MOVLW  08
02A9E:  MOVWF  FF7
02AA0:  MOVLW  00
02AA2:  MOVWF  FF8
02AA4:  CALL   09B4
....................       auxINTERFON=0; 
02AA8:  MOVLB  1
02AAA:  BCF    x0A.3
....................       auxBO_open=0; 
02AAC:  BCF    x0C.2
....................       auxCheck_in=0; 
02AAE:  BCF    x0C.1
....................       flagBlockI13=0; 
02AB0:  MOVLB  0
02AB2:  BCF    xFF.2
02AB4:  MOVLB  1
....................      }  
....................  //ACESSO NÃO RESIDENTES 
....................  if(ING_I1 && ING_I13 && !auxNotRES && flagEstadoME && !flagBlockI13)      // Detecção Não residentes com leitor ativo 
02AB6:  MOVLB  0
02AB8:  BTFSS  xC8.0
02ABA:  BRA    2AFC
02ABC:  BTFSS  xCA.4
02ABE:  BRA    2AFC
02AC0:  MOVLB  1
02AC2:  BTFSS  x0A.1
02AC4:  BRA    2ACA
02AC6:  MOVLB  0
02AC8:  BRA    2AFC
02ACA:  MOVLB  0
02ACC:  BTFSS  xD5.6
02ACE:  BRA    2AFC
02AD0:  BTFSC  xFF.2
02AD2:  BRA    2AFC
....................    {  
....................       auxNotRES=1; 
02AD4:  MOVLB  1
02AD6:  BSF    x0A.1
....................       auxNotRESBarAux=1; 
02AD8:  BSF    x0A.7
....................       if(debug) 
02ADA:  MOVLB  0
02ADC:  BTFSS  xD5.4
02ADE:  BRA    2AF0
....................         fprintf(PORT2,"N Residente. Abrir Barreiras."); 
02AE0:  MOVLW  38
02AE2:  MOVWF  FF6
02AE4:  MOVLW  08
02AE6:  MOVWF  FF7
02AE8:  MOVLW  00
02AEA:  MOVWF  FF8
02AEC:  CALL   09B4
....................       ABRE_P_ENT=1;   
02AF0:  MOVLB  1
02AF2:  BSF    x0B.3
....................       ABRE_BARR_AUX=1; 
02AF4:  BSF    x0B.2
....................       auxCheck_in=1; 
02AF6:  BSF    x0C.1
....................       //ABRE_P_ENT=1; 
....................    } 
02AF8:  BRA    2B2A
02AFA:  MOVLB  0
....................  else 
....................  if(!ING_I1 && auxNotRES) 
02AFC:  BTFSC  xC8.0
02AFE:  BRA    2B2C
02B00:  MOVLB  1
02B02:  BTFSC  x0A.1
02B04:  BRA    2B0A
02B06:  MOVLB  0
02B08:  BRA    2B2C
....................      { 
....................       if(debug) 
02B0A:  MOVLB  0
02B0C:  BTFSS  xD5.4
02B0E:  BRA    2B20
....................          fprintf(PORT2,"Carregar TimerG12"); 
02B10:  MOVLW  56
02B12:  MOVWF  FF6
02B14:  MOVLW  08
02B16:  MOVWF  FF7
02B18:  MOVLW  00
02B1A:  MOVWF  FF8
02B1C:  CALL   09B4
....................       TIMER_G12=Tempos[9]; 
02B20:  MOVFF  EB,E0
....................       auxNotRES=0; 
02B24:  MOVLB  1
02B26:  BCF    x0A.1
....................       auxBO_open=0; 
02B28:  BCF    x0C.2
02B2A:  MOVLB  0
....................      } 
....................  // ACESSO RESIDENTES 
....................  if(ING_I1 && ING_I12 && !auxRES && flagEstadoME)      // Detecção Residentes com leitor ativo 
02B2C:  BTFSS  xC8.0
02B2E:  BRA    2B6A
02B30:  BTFSS  xCA.3
02B32:  BRA    2B6A
02B34:  MOVLB  1
02B36:  BTFSS  x0A.2
02B38:  BRA    2B3E
02B3A:  MOVLB  0
02B3C:  BRA    2B6A
02B3E:  MOVLB  0
02B40:  BTFSS  xD5.6
02B42:  BRA    2B6A
....................    { auxRES=1; 
02B44:  MOVLB  1
02B46:  BSF    x0A.2
....................      if(debug) 
02B48:  MOVLB  0
02B4A:  BTFSS  xD5.4
02B4C:  BRA    2B5E
....................        fprintf(PORT2,"Residente. Abrir Barreira e Portao RES."); 
02B4E:  MOVLW  68
02B50:  MOVWF  FF6
02B52:  MOVLW  08
02B54:  MOVWF  FF7
02B56:  MOVLW  00
02B58:  MOVWF  FF8
02B5A:  CALL   09B4
....................      ABRE_P_ENT=1; 
02B5E:  MOVLB  1
02B60:  BSF    x0B.3
....................      ABRE_P_RES=1; 
02B62:  BSF    x0B.4
....................      auxCheck_in=1; 
02B64:  BSF    x0C.1
....................    } 
02B66:  BRA    2B9A
02B68:  MOVLB  0
....................  else 
....................    if(!ING_I1 && auxRES) 
02B6A:  BTFSC  xC8.0
02B6C:  BRA    2B9C
02B6E:  MOVLB  1
02B70:  BTFSC  x0A.2
02B72:  BRA    2B78
02B74:  MOVLB  0
02B76:  BRA    2B9C
....................      { 
....................       TIMER_G13=Tempos[11]; 
02B78:  MOVFF  ED,E1
....................       if(debug) 
02B7C:  MOVLB  0
02B7E:  BTFSS  xD5.4
02B80:  BRA    2B92
....................         fprintf(PORT2,"Vou carregar o TimerG13"); 
02B82:  MOVLW  90
02B84:  MOVWF  FF6
02B86:  MOVLW  08
02B88:  MOVWF  FF7
02B8A:  MOVLW  00
02B8C:  MOVWF  FF8
02B8E:  CALL   09B4
....................       auxRES=0; 
02B92:  MOVLB  1
02B94:  BCF    x0A.2
....................       auxBO_open=0; 
02B96:  BCF    x0C.2
....................       auxCheck_in=0; 
02B98:  BCF    x0C.1
02B9A:  MOVLB  0
....................      }  
....................   
.................... /*if(ING_I1 && ING_I9 && !auxBO_open && !auxCheck_in && flagEstadoME)         //Barreira Aberta 
....................    auxBO_open=1; 
.................... else 
....................   if(!ING_I1 && ING_I9 && !auxCheck_in && auxBO_open)  
....................     { 
....................      fprintf(PORT2,"Parque Offline. Barreiras Abertas. Carregar Timers"); 
....................      TIMER_G13=Tempos[11]; 
....................      TIMER_G12=Tempos[11]; 
....................      auxBO_open=0; 
....................      ABRE_P_RES=1; 
....................      ABRE_BARR_AUX=1; 
....................     } 
....................  */ 
....................   
....................  // ESPIRA DE SAIDA -2 
.................... if(ING_I1 && flagEstadoME && !flag_maqAtiva) 
02B9C:  BTFSS  xC8.0
02B9E:  BRA    2BAC
02BA0:  BTFSS  xD5.6
02BA2:  BRA    2BAC
02BA4:  BTFSC  xFF.0
02BA6:  BRA    2BAC
....................  { 
....................     output_low(OUT1); 
02BA8:  BCF    F8D.4
....................     flag_maqAtiva=1; 
02BAA:  BSF    xFF.0
....................   } 
....................  if(!ING_I1 && flag_maqAtiva)  //if(!ING_I1 && flagEstadoME==0) 
02BAC:  BTFSC  xC8.0
02BAE:  BRA    2BB8
02BB0:  BTFSS  xFF.0
02BB2:  BRA    2BB8
....................  { 
....................    output_high(OUT1); 
02BB4:  BSF    F8D.4
....................    flag_maqAtiva=0; 
02BB6:  BCF    xFF.0
....................  } 
....................  if(ING_I2 && flagEstadoMS && !flag_maqSaidaAtiva)  //if(ING_I1 && flagEstadoME==1) 
02BB8:  BTFSS  xC8.1
02BBA:  BRA    2BC8
02BBC:  BTFSS  xD5.7
02BBE:  BRA    2BC8
02BC0:  BTFSC  xFF.1
02BC2:  BRA    2BC8
....................  { 
....................    output_low(OUT2); 
02BC4:  BCF    F8D.5
....................    flag_maqSaidaAtiva=1; 
02BC6:  BSF    xFF.1
....................  } 
....................   
.................... if(!ING_I2 && flag_maqSaidaAtiva)  //if(ING_I1 && flagEstadoME==1) 
02BC8:  BTFSC  xC8.1
02BCA:  BRA    2BD4
02BCC:  BTFSS  xFF.1
02BCE:  BRA    2BD4
....................  {    
....................    output_high(OUT2); 
02BD0:  BSF    F8D.5
....................    flag_maqSaidaAtiva=0; 
02BD2:  BCF    xFF.1
....................  } 
....................   
.................... if(ING_I7 && !aux_P_RES) 
02BD4:  BTFSS  xC8.6
02BD6:  BRA    2BE8
02BD8:  MOVLB  1
02BDA:  BTFSS  x0A.5
02BDC:  BRA    2BE2
02BDE:  MOVLB  0
02BE0:  BRA    2BE8
....................   { 
....................    ABRE_P_RES=1; 
02BE2:  BSF    x0B.4
....................    aux_P_RES=1; 
02BE4:  BSF    x0A.5
02BE6:  MOVLB  0
....................   } 
.................... if(!ING_I7) 
02BE8:  BTFSC  xC8.6
02BEA:  BRA    2BF2
....................     aux_P_RES=0; 
02BEC:  MOVLB  1
02BEE:  BCF    x0A.5
02BF0:  MOVLB  0
....................  // ESPIRA DE SAIDA -1 
.................... if(ING_I5 && !aux_B_ENT) 
02BF2:  BTFSS  xC8.4
02BF4:  BRA    2C08
02BF6:  MOVLB  1
02BF8:  BTFSS  x0A.6
02BFA:  BRA    2C00
02BFC:  MOVLB  0
02BFE:  BRA    2C08
....................   { 
....................    ABRE_BARR_ENT=1; 
02C00:  BSF    x0B.1
....................    ABRE_P_ENT=1; 
02C02:  BSF    x0B.3
....................    aux_B_ENT=1; 
02C04:  BSF    x0A.6
02C06:  MOVLB  0
....................   } 
.................... if(!ING_I5) 
02C08:  BTFSC  xC8.4
02C0A:  BRA    2C12
....................   aux_B_ENT=0; 
02C0C:  MOVLB  1
02C0E:  BCF    x0A.6
02C10:  MOVLB  0
....................  //ESPIRA MEIO CAMINHO SENTIDO DESCENDENTE - ABRIR BARREIRA AUXILIAR. 
....................   
.................... if(ING_I4 && auxNotRESBarAux && !BarAuxFim) 
02C12:  BTFSS  xC8.3
02C14:  BRA    2C2E
02C16:  MOVLB  1
02C18:  BTFSC  x0A.7
02C1A:  BRA    2C20
02C1C:  MOVLB  0
02C1E:  BRA    2C2E
02C20:  BTFSS  x0B.0
02C22:  BRA    2C28
02C24:  MOVLB  0
02C26:  BRA    2C2E
.................... { 
.................... ABRE_BARR_AUX=1; 
02C28:  BSF    x0B.2
.................... BarAuxFim=1; 
02C2A:  BSF    x0B.0
02C2C:  MOVLB  0
.................... } 
.................... if(!ING_I4 && BarAuxFim) 
02C2E:  BTFSC  xC8.3
02C30:  BRA    2C42
02C32:  MOVLB  1
02C34:  BTFSC  x0B.0
02C36:  BRA    2C3C
02C38:  MOVLB  0
02C3A:  BRA    2C42
.................... { 
.................... auxNotRESBarAux=0; 
02C3C:  BCF    x0A.7
.................... BarAuxFim=0; 
02C3E:  BCF    x0B.0
02C40:  MOVLB  0
.................... }  
....................  
....................  
....................  switch(step){ 
02C42:  MOVF   xFE,W
02C44:  ADDLW  F7
02C46:  BTFSC  FD8.0
02C48:  BRA    2EBE
02C4A:  ADDLW  09
02C4C:  GOTO   2FD2
....................         case 0:if(TIMER_A>=Tempos[0]-Tempos[2])      //Verde mínimo G1 
02C50:  MOVF   xE4,W
02C52:  SUBWF  xE2,W
02C54:  SUBWF  xDB,W
02C56:  BNC   2C6A
....................                   {MEM_I1=0; 
02C58:  BCF    xC9.0
....................                    step=1; 
02C5A:  MOVLW  01
02C5C:  MOVWF  xFE
....................                    auxTime=Tempos[0]-Tempos[2]; 
02C5E:  MOVF   xE4,W
02C60:  SUBWF  xE2,W
02C62:  MOVLB  1
02C64:  MOVWF  x06
....................                    TIMER_A=0; 
02C66:  MOVLB  0
02C68:  CLRF   xDB
....................                   } 
....................                break; 
02C6A:  BRA    2EBE
....................         case 1:if(TIMER_A>=Tempos[2])  
02C6C:  MOVF   xE4,W
02C6E:  SUBWF  xDB,W
02C70:  BNC   2CBE
....................                  { 
....................                   auxTime=auxTime+Tempos[2]; 
02C72:  MOVF   xE4,W
02C74:  MOVLB  1
02C76:  ADDWF  x06,F
....................                   if((auxTime>Tempos[1] || !MEM_I1) && (MEM_I2 || MEM_I3))  // 
02C78:  MOVF   x06,W
02C7A:  MOVLB  0
02C7C:  SUBWF  xE3,W
02C7E:  BNC   2C84
02C80:  BTFSC  xC9.0
02C82:  BRA    2CBA
02C84:  BTFSC  xC9.1
02C86:  BRA    2C8C
02C88:  BTFSS  xC9.2
02C8A:  BRA    2CBA
....................                     { 
....................                      if(MEM_I2) 
02C8C:  BTFSS  xC9.1
02C8E:  BRA    2C96
....................                         step=2; 
02C90:  MOVLW  02
02C92:  MOVWF  xFE
02C94:  BRA    2CA0
....................                 else 
....................                        {step=5; 
02C96:  MOVLW  05
02C98:  MOVWF  xFE
....................                         cleartime=0; 
02C9A:  MOVLB  1
02C9C:  CLRF   x07
02C9E:  MOVLB  0
....................                   //  cleartime=Tempos[11];        // Tempo limpeza G1->G3 
....................                        } 
....................                      TIMER_A=0; 
02CA0:  CLRF   xDB
....................                      EstadoGrupos(1,1,1);          //0: Verde, 1:VErmelho,3:Mantêm        //ALLRED 
02CA2:  MOVLW  01
02CA4:  MOVLB  1
02CA6:  MOVWF  x0D
02CA8:  MOVWF  x0E
02CAA:  MOVWF  x0F
02CAC:  MOVLB  0
02CAE:  CALL   0A74
....................                      blockENT=0; 
02CB2:  MOVLB  1
02CB4:  BCF    x0A.4
....................                     } 
02CB6:  BRA    2CC0
02CB8:  MOVLB  0
....................                   else 
....................                     {TIMER_A=0; 
02CBA:  CLRF   xDB
....................                      MEM_I1=0; 
02CBC:  BCF    xC9.0
02CBE:  MOVLB  1
....................                     } 
....................                  }    
....................                break;    
02CC0:  MOVLB  0
02CC2:  BRA    2EBE
....................         case 2:if(TIMER_A<5 && ING_I1)  
02CC4:  MOVF   xDB,W
02CC6:  SUBLW  04
02CC8:  BNC   2CEA
02CCA:  BTFSS  xC8.0
02CCC:  BRA    2CEA
....................                  {   
....................                   blockENT=1; 
02CCE:  MOVLB  1
02CD0:  BSF    x0A.4
....................                    //Máquina de entrada ativada no tempo extra. 
....................                   flagEstadoME=1; 
02CD2:  MOVLB  0
02CD4:  BSF    xD5.6
....................                   if(debug) 
02CD6:  BTFSS  xD5.4
02CD8:  BRA    2CEA
....................                     fprintf(PORT2,"Chamada I1, Bloqueei"); 
02CDA:  MOVLW  A8
02CDC:  MOVWF  FF6
02CDE:  MOVLW  08
02CE0:  MOVWF  FF7
02CE2:  MOVLW  00
02CE4:  MOVWF  FF8
02CE6:  CALL   09B4
....................                  } 
....................                if(!ING_I1 && TIMER_A>=5 && blockENT) // if(!ING_I1 && TIMER_A>=5 && blockENT) 
02CEA:  BTFSC  xC8.0
02CEC:  BRA    2D18
02CEE:  MOVF   xDB,W
02CF0:  SUBLW  04
02CF2:  BC    2D18
02CF4:  MOVLB  1
02CF6:  BTFSC  x0A.4
02CF8:  BRA    2CFE
02CFA:  MOVLB  0
02CFC:  BRA    2D18
....................                  {     
....................                   blockENT=0; 
02CFE:  BCF    x0A.4
....................                   flagEstadoME=0; 
02D00:  MOVLB  0
02D02:  BCF    xD5.6
....................                   if(debug) 
02D04:  BTFSS  xD5.4
02D06:  BRA    2D18
....................                      fprintf(PORT2,"Chamada I1 Saiu, Desloqueei");              
02D08:  MOVLW  BE
02D0A:  MOVWF  FF6
02D0C:  MOVLW  08
02D0E:  MOVWF  FF7
02D10:  MOVLW  00
02D12:  MOVWF  FF8
02D14:  CALL   09B4
....................                   }    
....................                if(TIMER_G12==0 && TIMER_G13==0 && !ING_I11 && !blockENT && TIMER_A>=5 || TIMER_A>=Tempos[15])                //limpeza G1->G2  //TIMER_A>=Tempos[9] 
02D18:  MOVF   xE0,F
02D1A:  BNZ   2D36
02D1C:  MOVF   xE1,F
02D1E:  BNZ   2D36
02D20:  BTFSC  xCA.2
02D22:  BRA    2D36
02D24:  MOVLB  1
02D26:  BTFSS  x0A.4
02D28:  BRA    2D2E
02D2A:  MOVLB  0
02D2C:  BRA    2D36
02D2E:  MOVLB  0
02D30:  MOVF   xDB,W
02D32:  SUBLW  04
02D34:  BNC   2D3C
02D36:  MOVF   xF1,W
02D38:  SUBWF  xDB,W
02D3A:  BNC   2D52
....................                  {step=3; 
02D3C:  MOVLW  03
02D3E:  MOVWF  xFE
....................                   TIMER_A=0; 
02D40:  CLRF   xDB
....................                   EstadoGrupos(1,0,1);             //0: Verde, 1:VErmelho,3:Mantêm           //G2 Verde 
02D42:  MOVLW  01
02D44:  MOVLB  1
02D46:  MOVWF  x0D
02D48:  CLRF   x0E
02D4A:  MOVWF  x0F
02D4C:  MOVLB  0
02D4E:  CALL   0A74
....................                  } 
....................                break; 
02D52:  BRA    2EBE
....................         case 3:if(TIMER_A>=Tempos[3]-Tempos[5])      //Verde mínimo G2 
02D54:  MOVF   xE7,W
02D56:  SUBWF  xE5,W
02D58:  SUBWF  xDB,W
02D5A:  BNC   2D6E
....................                   { 
....................                    MEM_I2=0; 
02D5C:  BCF    xC9.1
....................                    step=4; 
02D5E:  MOVLW  04
02D60:  MOVWF  xFE
....................                    auxTime=Tempos[3]-Tempos[5]; 
02D62:  MOVF   xE7,W
02D64:  SUBWF  xE5,W
02D66:  MOVLB  1
02D68:  MOVWF  x06
....................                    TIMER_A=0; 
02D6A:  MOVLB  0
02D6C:  CLRF   xDB
....................                   } 
....................                break;                      
02D6E:  BRA    2EBE
....................         case 4:if(TIMER_A>=Tempos[5])  
02D70:  MOVF   xE7,W
02D72:  SUBWF  xDB,W
02D74:  BNC   2DB6
....................                  { 
....................                   auxTime=auxTime+Tempos[5]; 
02D76:  MOVF   xE7,W
02D78:  MOVLB  1
02D7A:  ADDWF  x06,F
....................                   if((auxTime>Tempos[4] || !MEM_I2)) 
02D7C:  MOVF   x06,W
02D7E:  MOVLB  0
02D80:  SUBWF  xE6,W
02D82:  BNC   2D88
02D84:  BTFSC  xC9.1
02D86:  BRA    2DB2
....................                     { 
....................                      if(MEM_I3)                      
02D88:  BTFSS  xC9.2
02D8A:  BRA    2D96
....................                        {step=5; 
02D8C:  MOVLW  05
02D8E:  MOVWF  xFE
....................                         cleartime=Tempos[13]; // Tempo limpeza G2->G3 
02D90:  MOVFF  EF,107
....................                        } 
02D94:  BRA    2D9E
....................                      else 
....................                        {step=8; 
02D96:  MOVLW  08
02D98:  MOVWF  xFE
....................                         cleartime=Tempos[10];  //Tempo limpeza G2->G1 (Subida) 
02D9A:  MOVFF  EC,107
....................                        }  
....................                       
....................                      TIMER_A=0; 
02D9E:  CLRF   xDB
....................                      EstadoGrupos(1,1,1); //0: Verde, 1:VErmelho,3:Mantêm        //ALLRED 
02DA0:  MOVLW  01
02DA2:  MOVLB  1
02DA4:  MOVWF  x0D
02DA6:  MOVWF  x0E
02DA8:  MOVWF  x0F
02DAA:  MOVLB  0
02DAC:  CALL   0A74
....................                     } 
02DB0:  BRA    2DB6
....................                   else 
....................                     {TIMER_A=0; 
02DB2:  CLRF   xDB
....................                      MEM_I2=0;   
02DB4:  BCF    xC9.1
....................                     } 
....................                  } 
....................                break; 
02DB6:  BRA    2EBE
....................         case 5:if(TIMER_A<5 && ING_I1) //Não é MEM_I1? NÃO ESTÁ A ENTRAR NA CONDIÇÃO if(TIMER_A<5 && ING_I1) 
02DB8:  MOVF   xDB,W
02DBA:  SUBLW  04
02DBC:  BNC   2DDE
02DBE:  BTFSS  xC8.0
02DC0:  BRA    2DDE
....................                  {   
....................                   blockENT=1; 
02DC2:  MOVLB  1
02DC4:  BSF    x0A.4
....................                   flagEstadoME=1; 
02DC6:  MOVLB  0
02DC8:  BSF    xD5.6
....................                   if(debug) 
02DCA:  BTFSS  xD5.4
02DCC:  BRA    2DDE
....................                     fprintf(PORT2,"Chamada I1, Bloqueei"); 
02DCE:  MOVLW  DA
02DD0:  MOVWF  FF6
02DD2:  MOVLW  08
02DD4:  MOVWF  FF7
02DD6:  MOVLW  00
02DD8:  MOVWF  FF8
02DDA:  CALL   09B4
....................                  } 
....................                if(!ING_I1 && TIMER_A>=5 && blockENT) // if(!ING_I1 && TIMER_A>=5 && blockENT) 
02DDE:  BTFSC  xC8.0
02DE0:  BRA    2E0C
02DE2:  MOVF   xDB,W
02DE4:  SUBLW  04
02DE6:  BC    2E0C
02DE8:  MOVLB  1
02DEA:  BTFSC  x0A.4
02DEC:  BRA    2DF2
02DEE:  MOVLB  0
02DF0:  BRA    2E0C
....................                  {     
....................                   blockENT=0; 
02DF2:  BCF    x0A.4
....................                   flagEstadoME=0; 
02DF4:  MOVLB  0
02DF6:  BCF    xD5.6
....................                   if(debug) 
02DF8:  BTFSS  xD5.4
02DFA:  BRA    2E0C
....................                     fprintf(PORT2,"Chamada I1 Saiu, Desloqueei"); 
02DFC:  MOVLW  F0
02DFE:  MOVWF  FF6
02E00:  MOVLW  08
02E02:  MOVWF  FF7
02E04:  MOVLW  00
02E06:  MOVWF  FF8
02E08:  CALL   09B4
....................                  }   
....................           /*     if(TIMER_A>=cleartime)                //Sentido G1->G3  (vai ser 0) 
....................                  {step=6; 
....................                   TIMER_A=0; 
....................                   EstadoGrupos(1,1,0);             //0: Verde, 1:VErmelho,3:Mantêm           //G2 Verde 
....................                  }*/ 
....................              if(TIMER_G13==0 && !blockENT && TIMER_A>=5 && TIMER_A>=cleartime || TIMER_A>=Tempos[15])                //limpeza G1->G3  //TIMER_A>=Tempos[9] 
02E0C:  MOVF   xE1,F
02E0E:  BNZ   2E2C
02E10:  MOVLB  1
02E12:  BTFSS  x0A.4
02E14:  BRA    2E1A
02E16:  MOVLB  0
02E18:  BRA    2E2C
02E1A:  MOVLB  0
02E1C:  MOVF   xDB,W
02E1E:  SUBLW  04
02E20:  BC    2E2C
02E22:  MOVLB  1
02E24:  MOVF   x07,W
02E26:  MOVLB  0
02E28:  SUBWF  xDB,W
02E2A:  BC    2E32
02E2C:  MOVF   xF1,W
02E2E:  SUBWF  xDB,W
02E30:  BNC   2E48
....................                  {step=6; 
02E32:  MOVLW  06
02E34:  MOVWF  xFE
....................                   TIMER_A=0; 
02E36:  CLRF   xDB
....................                   EstadoGrupos(1,1,0);             //0: Verde, 1:VErmelho,3:Mantêm           //G2 Verde 
02E38:  MOVLW  01
02E3A:  MOVLB  1
02E3C:  MOVWF  x0D
02E3E:  MOVWF  x0E
02E40:  CLRF   x0F
02E42:  MOVLB  0
02E44:  CALL   0A74
....................                  }  
....................                break;               
02E48:  BRA    2EBE
....................         case 6:if(TIMER_A>=Tempos[6]-Tempos[8])      //Verde mínimo G3 
02E4A:  MOVF   xEA,W
02E4C:  SUBWF  xE8,W
02E4E:  SUBWF  xDB,W
02E50:  BNC   2E64
....................                   { 
....................                    MEM_I3=0; 
02E52:  BCF    xC9.2
....................                    step=7; 
02E54:  MOVLW  07
02E56:  MOVWF  xFE
....................                    auxTime=Tempos[6]-Tempos[8]; 
02E58:  MOVF   xEA,W
02E5A:  SUBWF  xE8,W
02E5C:  MOVLB  1
02E5E:  MOVWF  x06
....................                    TIMER_A=0; 
02E60:  MOVLB  0
02E62:  CLRF   xDB
....................                   } 
....................                break;                 
02E64:  BRA    2EBE
....................         case 7:if(TIMER_A>=Tempos[8])  
02E66:  MOVF   xEA,W
02E68:  SUBWF  xDB,W
02E6A:  BNC   2E9E
....................                  { 
....................                   auxTime=auxTime+Tempos[8]; 
02E6C:  MOVF   xEA,W
02E6E:  MOVLB  1
02E70:  ADDWF  x06,F
....................                   if((auxTime>Tempos[7] || !MEM_I3)) 
02E72:  MOVF   x06,W
02E74:  MOVLB  0
02E76:  SUBWF  xE9,W
02E78:  BNC   2E7E
02E7A:  BTFSC  xC9.2
02E7C:  BRA    2E9A
....................                     { 
....................                      step=8; 
02E7E:  MOVLW  08
02E80:  MOVWF  xFE
....................                      cleartime=Tempos[12];  //Tempo limpeza G3->G1 (Subida) 
02E82:  MOVFF  EE,107
....................                      TIMER_A=0; 
02E86:  CLRF   xDB
....................                      EstadoGrupos(1,1,1); //0: Verde, 1:VErmelho,3:Mantêm        //ALLRED 
02E88:  MOVLW  01
02E8A:  MOVLB  1
02E8C:  MOVWF  x0D
02E8E:  MOVWF  x0E
02E90:  MOVWF  x0F
02E92:  MOVLB  0
02E94:  CALL   0A74
....................                     } 
02E98:  BRA    2E9E
....................                   else 
....................                     {TIMER_A=0; 
02E9A:  CLRF   xDB
....................                      MEM_I3=0;   
02E9C:  BCF    xC9.2
....................                     } 
....................                  } 
....................                break;                                
02E9E:  BRA    2EBE
....................         case 8:if(TIMER_A>=cleartime)    //Sentido Saída p/ entrada 
02EA0:  MOVLB  1
02EA2:  MOVF   x07,W
02EA4:  MOVLB  0
02EA6:  SUBWF  xDB,W
02EA8:  BNC   2EBE
....................                  {step=0; 
02EAA:  CLRF   xFE
....................                   TIMER_A=0; 
02EAC:  CLRF   xDB
....................                   EstadoGrupos(0,1,1); //0: Verde, 1:VErmelho,3:Mantêm   //G2 Verde 
02EAE:  MOVLB  1
02EB0:  CLRF   x0D
02EB2:  MOVLW  01
02EB4:  MOVWF  x0E
02EB6:  MOVWF  x0F
02EB8:  MOVLB  0
02EBA:  CALL   0A74
....................                  } 
....................                break;         
....................         } 
....................  
.................... //Pulsos para Barreiras 
.................... if(ABRE_BARR_ENT) 
02EBE:  MOVLB  1
02EC0:  BTFSS  x0B.1
02EC2:  BRA    2EEA
....................   { 
....................    if(debug) 
02EC4:  MOVLB  0
02EC6:  BTFSS  xD5.4
02EC8:  BRA    2EDA
....................      fprintf(PORT2,"Pulso barreira de entrada"); 
02ECA:  MOVLW  0C
02ECC:  MOVWF  FF6
02ECE:  MOVLW  09
02ED0:  MOVWF  FF7
02ED2:  MOVLW  00
02ED4:  MOVWF  FF8
02ED6:  CALL   09B4
....................    PULSO_1=1; 
02EDA:  MOVLB  1
02EDC:  BSF    x0B.5
....................    output_low(OUT5); //PULSO ON Instante 0 ms; Abro Barreira de Entrada 
02EDE:  BCF    F8A.0
....................    TIMER_B=0; 
02EE0:  MOVLB  0
02EE2:  CLRF   xDC
....................    count_timerB=0; 
02EE4:  CLRF   xD7
....................    ABRE_BARR_ENT=0; 
02EE6:  MOVLB  1
02EE8:  BCF    x0B.1
....................   } 
.................... if(PULSO_1 && TIMER_B>1) 
02EEA:  BTFSS  x0B.5
02EEC:  BRA    2F02
02EEE:  MOVLB  0
02EF0:  MOVF   xDC,W
02EF2:  SUBLW  01
02EF4:  BTFSS  FD8.0
02EF6:  BRA    2EFC
02EF8:  MOVLB  1
02EFA:  BRA    2F02
....................   {  
....................     output_high(OUT5);  //PULSO OFF Instante 1000 ms 
02EFC:  BSF    F8A.0
....................     PULSO_1=0; 
02EFE:  MOVLB  1
02F00:  BCF    x0B.5
....................   } 
....................    
.................... if(ABRE_BARR_AUX) 
02F02:  BTFSS  x0B.2
02F04:  BRA    2F2E
....................   { 
....................    if(debug) 
02F06:  MOVLB  0
02F08:  BTFSS  xD5.4
02F0A:  BRA    2F1C
....................      fprintf(PORT2,"Pulso barreira auxiliar."); 
02F0C:  MOVLW  26
02F0E:  MOVWF  FF6
02F10:  MOVLW  09
02F12:  MOVWF  FF7
02F14:  MOVLW  00
02F16:  MOVWF  FF8
02F18:  CALL   09B4
....................    PULSO_2=1; 
02F1C:  MOVLB  1
02F1E:  BSF    x0B.6
....................    output_low(OUT6); //PULSO ON Instante 0 ms; Abro Barreira Auxiliar 
02F20:  BCF    F94.5
02F22:  BCF    F8B.5
....................    TIMER_C=0; 
02F24:  MOVLB  0
02F26:  CLRF   xDD
....................    count_timerC=0; 
02F28:  CLRF   xD8
....................    ABRE_BARR_AUX=0; 
02F2A:  MOVLB  1
02F2C:  BCF    x0B.2
....................   } 
.................... if(PULSO_2 && TIMER_C>1) 
02F2E:  BTFSS  x0B.6
02F30:  BRA    2F48
02F32:  MOVLB  0
02F34:  MOVF   xDD,W
02F36:  SUBLW  01
02F38:  BTFSS  FD8.0
02F3A:  BRA    2F40
02F3C:  MOVLB  1
02F3E:  BRA    2F48
....................   { output_high(OUT6);  //PULSO OFF Instante 1000 ms 
02F40:  BCF    F94.5
02F42:  BSF    F8B.5
....................     PULSO_2=0; 
02F44:  MOVLB  1
02F46:  BCF    x0B.6
....................   } 
....................  //Pulsos para abrir Portões 
.................... if(ABRE_P_ENT) 
02F48:  BTFSS  x0B.3
02F4A:  BRA    2F72
....................   { 
....................    if(debug) 
02F4C:  MOVLB  0
02F4E:  BTFSS  xD5.4
02F50:  BRA    2F62
....................      fprintf(PORT2,"Pulso portao ent."); 
02F52:  MOVLW  40
02F54:  MOVWF  FF6
02F56:  MOVLW  09
02F58:  MOVWF  FF7
02F5A:  MOVLW  00
02F5C:  MOVWF  FF8
02F5E:  CALL   09B4
....................    PULSO_3=1; 
02F62:  MOVLB  1
02F64:  BSF    x0B.7
....................    output_low(OUT3); //PULSO ON Instante 0 ms; Abro Portao Entrada 
02F66:  BCF    F8D.6
....................    TIMER_D=0; 
02F68:  MOVLB  0
02F6A:  CLRF   xDE
....................    count_timerD=0; 
02F6C:  CLRF   xD9
....................    ABRE_P_ENT=0; 
02F6E:  MOVLB  1
02F70:  BCF    x0B.3
....................   } 
.................... if(PULSO_3 && TIMER_D>1) 
02F72:  BTFSS  x0B.7
02F74:  BRA    2F8A
02F76:  MOVLB  0
02F78:  MOVF   xDE,W
02F7A:  SUBLW  01
02F7C:  BTFSS  FD8.0
02F7E:  BRA    2F84
02F80:  MOVLB  1
02F82:  BRA    2F8A
....................   { output_high(OUT3);  //PULSO OFF Instante 1000 ms 
02F84:  BSF    F8D.6
....................     PULSO_3=0; 
02F86:  MOVLB  1
02F88:  BCF    x0B.7
....................   } 
....................   
.................... if(ABRE_P_RES) 
02F8A:  BTFSS  x0B.4
02F8C:  BRA    2FB4
....................   { 
....................    if(debug) 
02F8E:  MOVLB  0
02F90:  BTFSS  xD5.4
02F92:  BRA    2FA4
....................      fprintf(PORT2,"Pulso portao res."); 
02F94:  MOVLW  52
02F96:  MOVWF  FF6
02F98:  MOVLW  09
02F9A:  MOVWF  FF7
02F9C:  MOVLW  00
02F9E:  MOVWF  FF8
02FA0:  CALL   09B4
....................    PULSO_4=1; 
02FA4:  MOVLB  1
02FA6:  BSF    x0C.0
....................    output_low(OUT4); //PULSO ON Instante 0 ms;  Abro Portao Residentes 
02FA8:  BCF    F8D.7
....................    TIMER_E=0; 
02FAA:  MOVLB  0
02FAC:  CLRF   xDF
....................    count_timerE=0; 
02FAE:  CLRF   xDA
....................    ABRE_P_RES=0; 
02FB0:  MOVLB  1
02FB2:  BCF    x0B.4
....................   } 
.................... if(PULSO_4 && TIMER_E>1) 
02FB4:  BTFSS  x0C.0
02FB6:  BRA    2FCC
02FB8:  MOVLB  0
02FBA:  MOVF   xDF,W
02FBC:  SUBLW  01
02FBE:  BTFSS  FD8.0
02FC0:  BRA    2FC6
02FC2:  MOVLB  1
02FC4:  BRA    2FCC
....................   { output_high(OUT4);  //PULSO OFF Instante 1000 ms 
02FC6:  BSF    F8D.7
....................     PULSO_4=0; 
02FC8:  MOVLB  1
02FCA:  BCF    x0C.0
....................   } 
02FCC:  MOVLB  0
02FCE:  BRA    29D0
....................    
.................... // TEstes inputs 
.................... /* 
....................  if(ING_I1 && !aux1) 
....................    {fprintf(PORT2,"I1 ON\n\r"); 
....................     aux1=1; 
....................    } 
.................... if(!ING_I1 && aux1) 
....................   {fprintf(PORT2,"I1 OFF\n\r"); 
....................    aux1=0; 
....................    } 
....................   
.................... if(ING_I2 && !aux2) 
....................    {fprintf(PORT2,"I2 ON\n\r"); 
....................     aux2=1; 
....................    } 
.................... if(!ING_I2 && aux2) 
....................   {fprintf(PORT2,"I2 OFF\n\r"); 
....................    aux2=0; 
....................    } 
....................  
.................... if(ING_I3 && !aux3) 
....................    {fprintf(PORT2,"I3 ON\n\r"); 
....................     aux3=1; 
....................    } 
.................... if(!ING_I3 && aux3) 
....................   {fprintf(PORT2,"I3 OFF\n\r"); 
....................    aux3=0; 
....................    } 
....................  
.................... if(ING_I4 && !aux4) 
....................    {fprintf(PORT2,"I4 ON\n\r"); 
....................     aux4=1; 
....................    } 
....................     
.................... if(!ING_I4 && aux4) 
....................   {fprintf(PORT2,"I4 OFF\n\r"); 
....................    aux4=0; 
....................    } 
....................  
.................... if(ING_I5 && !aux5) 
....................    {fprintf(PORT2,"I5 ON\n\r"); 
....................     aux5=1; 
....................    } 
.................... if(!ING_I5 && aux5) 
....................   {fprintf(PORT2,"I5 OFF\n\r"); 
....................    aux5=0; 
....................    } 
....................  
.................... if(ING_I6 && !aux6) 
....................    {fprintf(PORT2,"I6 ON\n\r"); 
....................     aux6=1; 
....................    } 
.................... if(!ING_I6 && aux6) 
....................   {fprintf(PORT2,"I6 OFF\n\r"); 
....................    aux6=0; 
....................    } 
....................  
.................... if(ING_I7 && !aux7) 
....................    {fprintf(PORT2,"I7 ON\n\r"); 
....................     aux7=1; 
....................    } 
.................... if(!ING_I7 && aux7) 
....................   {fprintf(PORT2,"I7 OFF\n\r"); 
....................    aux7=0; 
....................    } 
....................  
.................... if(ING_I8 && !aux8) 
....................    {fprintf(PORT2,"I8 ON\n\r"); 
....................     aux8=1; 
....................    } 
.................... if(!ING_I8 && aux8) 
....................   {fprintf(PORT2,"I8 OFF\n\r"); 
....................    aux8=0; 
....................    } 
....................  
.................... if(ING_I9 && !aux9) 
....................    {fprintf(PORT2,"I9 ON\n\r"); 
....................     aux9=1; 
....................    } 
.................... if(!ING_I9 && aux9) 
....................   {fprintf(PORT2,"I9 OFF\n\r"); 
....................    aux9=0; 
....................    } 
....................  
.................... if(ING_I10 && !aux10) 
....................    {fprintf(PORT2,"I10 ON\n\r"); 
....................     aux10=1; 
....................    } 
.................... if(!ING_I10 && aux10) 
....................   {fprintf(PORT2,"I10 OFF\n\r"); 
....................    aux10=0; 
....................    } 
....................  
.................... if(ING_I11 && !aux11) 
....................    {fprintf(PORT2,"I11 ON\n\r"); 
....................     aux11=1; 
....................    } 
.................... if(!ING_I11 && aux11) 
....................   {fprintf(PORT2,"I11 OFF\n\r"); 
....................    aux11=0; 
....................    } 
....................  
.................... if(ING_I12 && !aux12) 
....................    {fprintf(PORT2,"I12 ON\n\r"); 
....................     aux12=1; 
....................    } 
.................... if(!ING_I12 && aux12) 
....................   {fprintf(PORT2,"I12 OFF\n\r"); 
....................    aux12=0; 
....................    } 
....................  
.................... if(ING_I13 && !aux13) 
....................    {fprintf(PORT2,"I13 ON\n\r"); 
....................     aux13=1; 
....................    } 
.................... if(!ING_I13 && aux13) 
....................   {fprintf(PORT2,"I13 OFF\n\r"); 
....................    aux13=0; 
....................    } 
....................  
.................... if(ING_I14 && !aux14) 
....................    {fprintf(PORT2,"I14 ON\n\r"); 
....................     aux14=1; 
....................    } 
.................... if(!ING_I14 && aux14) 
....................   {fprintf(PORT2,"I14 OFF\n\r"); 
....................    aux14=0; 
....................    } 
....................  
.................... if(ING_I15 && !aux15) 
....................    {fprintf(PORT2,"I15 ON\n\r"); 
....................     aux15=1; 
....................    } 
.................... if(!ING_I15 && aux15) 
....................   {fprintf(PORT2,"I15 OFF\n\r"); 
....................    aux15=0; 
....................    } 
....................  
.................... if(ING_I16 && !aux16) 
....................    {fprintf(PORT2,"I16 ON\n\r"); 
....................     aux16=1; 
....................    } 
.................... if(!ING_I16 && aux16) 
....................   {fprintf(PORT2,"I16 OFF\n\r"); 
....................    aux16=0; 
....................    }   
....................             
.................... */             
....................   
....................   
.................... /*  
.................... OUTPUT_E(0b11111101); //Activa rele 0 
.................... fprintf(PORT2,"RELE 0 -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... OUTPUT_E(0b11111100);  //Activa rele 0,1 
.................... fprintf(PORT2,"RELE 0,1 -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... OUTPUT_E(0b11111000); //Activa rele 0,1,2 
.................... fprintf(PORT2,"RELE 0,1,2 -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... OUTPUT_E(0b11110000);  //Activa rele 0,1,2,3 
.................... fprintf(PORT2,"RELE 0,1,2,3 -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... OUTPUT_E(0b11100000); //Activa rele 0,1,2,3,4 
.................... fprintf(PORT2,"RELE 0,1,2,3,4 -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... OUTPUT_E(0b11000000);  //Activa rele 0,1,2,3,4,5 
.................... fprintf(PORT2,"RELE 0,1,2,3,4,5 -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... OUTPUT_E(0b10000000); //Activa rele 0,1,2,3,4,5,6 
.................... fprintf(PORT2,"RELE 0,1,2,3,4,5,6 -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... OUTPUT_E(0b00000000); //Activa rele 0,1,2,3,4,5,6,7 
.................... fprintf(PORT2,"RELE 0,1,2,3,4,5,6,7 -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... output_low(PIN_B0);  //activa relé 8  //Activa rele 0,1,2,3,4,5,6,7,8 
.................... fprintf(PORT2,"RELE 0,1,2,3,4,5,6,7,8 -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... output_low(PIN_C5);  //Activa relé 7   //Activa rele 0,1,2,3,4,5,6,7,8,9 
.................... fprintf(PORT2,"RELE 0,1,2,3,4,5,6,7,8, -> ON\n\r"); 
.................... delay_seg(2); 
....................  
.................... OUTPUT_E(0b11111111);                   //Desliga rele 0,1,2,3,4,5,6,7 
.................... output_High(PIN_C5);  //Desliga relé 9 
.................... output_High(PIN_B0);  //Desliga relé 8 
.................... fprintf(PORT2,"Desliga Tudo -> ON\n\r"); 
.................... delay_seg(4); 
....................  
.................... */ 
....................  
.................... }//fim while(true) 1 
....................  
....................  
.................... }//fim main 
....................  
02FD0:  SLEEP 
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: F0A1   WDT STVREN NOXINST NODEBUG PROTECT
   Word  2: FDC4   HS PRIMARY FCMEN IESO WDT8192
   Word  3: F3F8   EASHFT MCU BW16 NOWAIT CCP2C1 ECCPE NOETHLED
